<?xml version="1.0" encoding="utf-8" ?>

<chapter id="database">
  <title>データベースのテスト</title>
  <para>
    初級者・中級者向けのユニットテストのサンプルは、
    どんな言語を対象としたものであっても、
    テストしやすいようなロジックに対してシンプルなテストをしているものばかりです。
    データベースを扱う一般的なアプリケーションを考えると、これはまったく現実離れしています。
    たとえば Wordpress や TYPO3、あるいは Symfony で Doctrine や Propel などを使い始めるとすぐに、
    PHPUnit でのテストがやりづらいことを実感するはずです。
    データベースとこれらのライブラリが密結合になっているからです。
  </para>
  <para>
    きっと日々の業務やプロジェクトでも身に覚えがあることでしょう。
    自分の持つ PHPUnit に関する知識を駆使して作業を進めようとしたのに、
    こんな問題のせいで行き詰ってしまうことが。
  </para>
  <orderedlist numeration="arabic">
    <listitem>
      <para>
        テストしたいメソッドがかなり大きめの JOIN 操作を実行し、
        データを使って重要な結果を算出している。
      </para>
    </listitem>
    <listitem>
      <para>
        ひとつのビジネスロジックの中で SELECT、INSERT、UPDATE そして DELETE
        を組み合わせて実行している。
      </para>
    </listitem>
    <listitem>
      <para>
        ふたつ以上の (おそらくもっと多い) テーブルから初期データを準備しないと
        そのメソッドのテストができない。
      </para>
    </listitem>
  </orderedlist>
  <para>
    DBUnit 拡張を使うと、テスト用のデータベースのセットアップを単純化でき、
    データベース操作後の内容の検証もすることができます。次のようにインストールします。
  </para>
  <screen><userinput>pear install phpunit/DbUnit</userinput></screen>
  <section id="database.supported-vendors-for-database-testing">
    <title>データベースのテストに対応しているベンダー</title>
    <para>
      DBUnit が現在サポートしているのは、MySQL および
      PostgreSQL、Oracle、SQLite です。
      <ulink url="http://framework.zend.com">Zend Framework</ulink> や
      <ulink url="http://www.doctrine-project.org">Doctrine 2</ulink>
      を使うと、IBM DB2 や Microsoft SQL Server のような他のデータベースにもアクセスできます。
    </para>
  </section>
  <section id="database.difficulties-in-database-testing">
    <title>データベースのテストの難しさ</title>
    <para>
      ウェブ上にあるユニットテストのサンプルの中にデータベースを扱うものが全く見当たらない理由はなぜか。
      それは、データベースを扱うテストは準備するのも保守するのもたいへんだからです。
      データベースを使うテストをするには、このようなことに気をつける必要があります。
    </para>
    <itemizedlist>
      <listitem>
        <para>
          データベースのスキーマやテーブル
        </para>
      </listitem>
      <listitem>
        <para>
          テーブルへの、テストで必要となるレコードの追加
        </para>
      </listitem>
      <listitem>
        <para>
          テスト実行後のデータベースの状態の検証
        </para>
      </listitem>
      <listitem>
        <para>
          テスト実行ごとのデータベースの後始末
        </para>
      </listitem>
    </itemizedlist>
    <para>
      PDO や MySQLi あるいは OCI8 といったデータベース API はどれも使いにくい上に、
      こういった処理を自分で書こうとすると長ったらしくなってしまって面倒です。
    </para>
    <para>
      テストコードはできる限り簡潔に、そして明確に書かねばなりません。その理由は次のとおりです。
    </para>
    <itemizedlist>
      <listitem>
        <para>
          製品コードにちょっと手を加えるたびに大量のテストコードを変更する羽目になるのは困る。
        </para>
      </listitem>
      <listitem>
        <para>
          数ヵ月後に改めて読み直したときにも
          読みやすく理解しやすいテストコードであってほしい。
        </para>
      </listitem>
    </itemizedlist>
    <para>
      さらに知っておく必要があることは、
      データベースは基本的に、自分のコードへのグローバルな入力変数であるということです。
      テストスイート内にあるふたつのテストを同じデータベースに対して実行すると、
      おそらくデータを複数回再利用することになります。あるテストが失敗すると
      それ以降のテストの結果にも影響を及ぼしやすく、テストを進めるのが非常に難しくなります。
      先ほど箇条書きでまとめた中の「後始末」こそが、この
      <quote>データベースがグローバルな入力になる</quote>
      問題を解決するために重要です。
    </para>
    <para>
      DbUnit を使うと、
      データベースのテストにおけるこれらの問題をシンプルにする助けになります。
    </para>
    <para>
      PHPUnit では助けようにもどうにもならないことが、
      データベースのテストはデータベースを使わないものに比べてとても遅くなるという事実です。
      テストの実行時間がどれくらいになるかはデータベースとのやりとりの量に依存しますが、
      各テストで使うデータの量を少なめにしておいて
      可能な限りはデータベースを使わないテストで済ませるようにすれば、
      巨大なテストスイートであっても 1 分未満で実行させるのは容易です。
    </para>
    <para>
      <ulink url="http://www.doctrine-project.org">Doctrine 2 プロジェクト</ulink> がよい例です。
      このプロジェクトのテストスイートには現時点で約 1000 件のテストが含まれています。
      そのほぼ半数がデータベースを扱うテストですが、
      標準的なデスクトップコンピューター上の MySQL
      を使ってテストスイートを実行しても 15 秒程度でテストが完了します。
    </para>
  </section>
  <section id="database.the-four-stages-of-a-database-test">
    <title>データベーステストの四段階</title>
    <para>
      Gerard Meszaros は、著書 xUnit Test Patterns でユニットテストを次の四段階に分類しています。
    </para>
    <orderedlist numeration="arabic">
      <listitem>
        <para>
          フィクスチャのセットアップ (Setup)
        </para>
      </listitem>
      <listitem>
        <para>
          テストしたいシステムの実行 (Exercise)
        </para>
      </listitem>
      <listitem>
        <para>
          結果の検証 (Verify)
        </para>
      </listitem>
      <listitem>
        <para>
          後始末 (Teardown)
        </para>
      </listitem>
    </orderedlist>
    <blockquote>
      <para>
        <emphasis role="strong">フィクスチャとは?</emphasis>
      </para>
      <para>
        フィクスチャとは、アプリケーションやデータベースの初期状態のことです。
        テストを実行する前に用意します。
      </para>
    </blockquote>
    <para>
      データベースをテストするには、少なくとも setup と teardown
      のときにはテーブルに接続してフィクスチャのクリーンアップや書き込みをしなければなりません。
      しかし、データベース拡張には、
      データベーステストの四段階を次のようなワークフローに振り向ける十分な理由があります。
      このフローは、個々のテストに対して実行します。
    </para>
    <section id="database.clean-up-database">
      <title>1. データベースのクリーンアップ</title>
      <para>
        データベースを扱う最初のテストというのはいつでも存在します。
        実際のところ、そのときテーブルにデータが存在するのかどうかはわかりません。
        PHPUnit は指定した全テーブルに対して TRUNCATE を実行し、
        テーブルの中身を空にします。
      </para>
    </section>
    <section id="database.set-up-fixture">
      <title>2. フィクスチャの準備</title>
      <para>
        その後、PHPUnit はフィクスチャの各行を順次処理し、対応するテーブルに書き込みます。
      </para>
    </section>
    <section id="database.run-test-verify-outcome-and-teardown">
      <title>3–5. テストの実行、結果の検証、そして後始末</title>
      <para>
        データベースをリセットして初期状態を読み込んだら、
        実際のテストを PHPUnit が実行します。
        テストコードのこの部分は Database Extension の存在を知っている必要はなく、
        コードに対してなんでもお好みのテストをすることができます。
      </para>
      <para>
        テストの中で <literal>assertDataSetsEqual()</literal>
        という特殊なアサーションを使って検証しているかもしれません。
        しかし、この機能は完全なオプションです。
        この機能は <quote>データベースアサーション</quote> で説明します。
      </para>
    </section>
  </section>
  <section id="database.configuration-of-a-phpunit-database-testcase">
    <title>PHPUnit のデータベーステストケースの設定</title>
    <para>
      通常、PHPUnit を使うテストケースでは
      <literal>PHPUnit_Framework_TestCase</literal>
      クラスを継承してこのようにします。
    </para>
    <programlisting><![CDATA[<?php
class MyTest extends PHPUnit_Framework_TestCase
{
    public function testCalculate()
    {
        $this->assertEquals(2, 1 + 1);
    }
}
?>]]></programlisting>
    <para>
      テストコードで Database Extension を使う場合は少しだけ複雑になり、
      別の抽象テストケースを継承しなければなりません。そして、二つの抽象メソッド
      <literal>getConnection()</literal> と
      <literal>getDataSet()</literal> を実装します。
    </para>
    <programlisting><![CDATA[<?php
class MyGuestbookTest extends PHPUnit_Extensions_Database_TestCase
{
    /**
     * @return PHPUnit_Extensions_Database_DB_IDatabaseConnection
     */
    public function getConnection()
    {
        $pdo = new PDO('sqlite::memory:');
        return $this->createDefaultDBConnection($pdo, ':memory:');
    }

    /**
     * @return PHPUnit_Extensions_Database_DataSet_IDataSet
     */
    public function getDataSet()
    {
        return $this->createFlatXMLDataSet(dirname(__FILE__).'/_files/guestbook-seed.xml');
    }
}
?>]]></programlisting>
    <section id="database.implementing-getconnection">
      <title>getConnection() の実装</title>
      <para>
        クリーンアップとフィクスチャの読み込みの機能を動かすには、
        PHPUnit Database Extension からデータベース接続にアクセスできなければなりません。
        データベース接続の抽象化には PDO ライブラリを使います。
        重要なのは、PHPUnit のデータベース拡張を使うためだけに
        わざわざアプリケーションを PDO ベースにする必要はないということです。
        この接続を使うのは、単にクリーンアップとフィクスチャの準備のためだけです。
      </para>
      <para>
        先ほどの例では、インメモリの SQLite 接続を作って
        <literal>createDefaultDBConnection</literal> メソッドに渡しました。
        このメソッドは PDO のインスタンスをラップしたもので、二番目のパラメータ
        (データベース名) に非常にシンプルなデータベース接続の抽象化レイヤーを渡します。このパラメータの型は
        <literal>PHPUnit_Extensions_Database_DB_IDatabaseConnection</literal> です。
      </para>
      <para>
        <quote>データベース接続の使い方</quote>で、このインターフェイスの API
        と、その活用法について説明します。
      </para>
    </section>
    <section id="database.implementing-getdataset">
      <title>getDataSet() の実装</title>
      <para>
        <literal>getDataSet()</literal> メソッドで定義するのは、
        個々のテストを実行する前のデータベースの初期状態がどうあるべきかということです。
        データベースの状態の抽象化は DataSet と DataTable
        という概念を使って行い、これらをそれぞれ
        <literal>PHPUnit_Extensions_Database_DataSet_IDataSet</literal> および
        <literal>PHPUnit_Extensions_Database_DataSet_IDataTable</literal>
        というインターフェイスで表します。次の節でこれらの概念を詳しく説明し、
        これをデータベースのテストに使うと何がうれしいのかについても示します。
      </para>
      <para>
        実装するために最低限知っておくべきことは、
        <literal>getDataSet()</literal> メソッドがコールされるのが
        <literal>setUp()</literal> の中で一度だけであり、
        ここでフィクスチャのデータセットを取得してデータベースに挿入するということです。
        先ほどの例では、ファクトリメソッド
        <literal>createFlatXMLDataSet($filename)</literal>
        を使って XML 形式のデータセットを表しました。
      </para>
    </section>
    <section id="database.what-about-the-database-schema-ddl">
      <title>データベーススキーマ (DDL) とは?</title>
      <para>
        PHPUnit は、テストの実行前にデータベーススキーマ
        (すべてのテーブル、トリガー、シーケンス、ビューを含むもの)
        ができあがっていることを想定しています。つまり開発者としては、
        テストスイートを実行する前にデータベースを正しく準備しておかねばならないということです。
      </para>
      <para>
        データベースのテストにおけるこの事前条件を満たす方法には、次のようなものがあります。
      </para>
      <orderedlist numeration="arabic">
        <listitem>
          <para>
            インメモリの SQLite ではなく永続化したデータベースを使うのなら、
            最初に一度 phpMyAdmin (MySQL の場合) などのツールでデータベースを用意しておけば、
            あとはテストを実行するたびにそれを再利用できます。
          </para>
        </listitem>
        <listitem>
          <para>
            <ulink url="http://www.doctrine-project.org">Doctrine 2</ulink> や
            <ulink url="http://www.propelorm.org/">Propel</ulink>
            といったライブラリを使っている場合は、その API を使えばテストの実行前に必要なデータベーススキーマを作ることができます。
            <ulink url="http://www.phpunit.de/manual/current/en/textui.html">PHPUnit のブートストラップ</ulink>
            機能を使うと、そのコードをテスト実行時に毎回実行させることもできます。
          </para>
        </listitem>
      </orderedlist>
    </section>
    <section id="database.tip-use-your-own-abstract-database-testcase">
      <title>ヒント: 自前でのデータベーステストケースの抽象化</title>
      <para>
        先の実装例を見ればすぐにわかるでしょうが、
        <literal>getConnection()</literal> メソッドはきわめて静的なものであり、
        さまざまなデータベーステストケースで再利用することができます。
        さらに、テストのパフォーマンスを良好に保ちつつデータベースのオーバーヘッドを下げるために、
        ちょっとしたリファクタリングを施して汎用的な抽象テストケースを用意しましょう。
        このようにしても、テストケースごとに異なるデータフィクスチャを指定することができます。
      </para>
      <programlisting><![CDATA[<?php
abstract class MyApp_Tests_DatabaseTestCase extends PHPUnit_Extensions_Database_TestCase
{
    // PDO のインスタンス生成は、クリーンアップおよびフィクスチャ読み込みのときに一度だけ
    static private $pdo = null;

    // PHPUnit_Extensions_Database_DB_IDatabaseConnection のインスタンス生成は、テストご    private $conn = null;

    final public function getConnection()
    {
        if ($this->conn === null) {
            if (self::$pdo == null) {
                self::$pdo = new PDO('sqlite::memory:');
            }
            $this->conn = $this->createDefaultDBConnection(self::$pdo, ':memory:');
        }

        return $this->conn;
    }
}
?>]]></programlisting>
      <para>
        しかし、これはまだデータベースへの接続情報を
        PDO 接続の設定にハードコードしてしまっています。
        PHPUnit にはさらにすばらしい機能があるので、それを使ってテストケースをより汎用的にしましょう。
        <ulink url="http://www.phpunit.de/manual/current/en/appendixes.configuration.html#appendixes.configuration.php-ini-constants-variables">XML 設定ファイル</ulink>
        を使えば、テストの実行のたびにデータベース接続を設定できます。
        まずは <quote>phpunit.xml</quote> というファイルをアプリケーションの tests/ ディレクトリに作り、
        中身をこのようにします。
      </para>
      <screen><![CDATA[
<?xml version="1.0" encoding="UTF-8" ?>
<phpunit>
    <php>
        <var name="DB_DSN" value="mysql:dbname=myguestbook;host=localhost" />
        <var name="DB_USER" value="user" />
        <var name="DB_PASSWD" value="passwd" />
        <var name="DB_DBNAME" value="myguestbook" />
    </php>
</phpunit>
]]></screen>
      <para>
        テストケースはこのように書き直せます。
      </para>
      <programlisting><![CDATA[<?php
abstract class Generic_Tests_DatabaseTestCase extends PHPUnit_Extensions_Database_TestCase
{
    // PDO のインスタンス生成は、クリーンアップおよびフィクスチャ読み込みのときに一度だけ
    static private $pdo = null;

    // PHPUnit_Extensions_Database_DB_IDatabaseConnection のインスタンス生成は、テストごとに一度だけ
    private $conn = null;

    final public function getConnection()
    {
        if ($this->conn === null) {
            if (self::$pdo == null) {
                self::$pdo = new PDO( $GLOBALS['DB_DSN'], $GLOBALS['DB_USER'], $GLOBALS['DB_PASSWD'] );
            }
            $this->conn = $this->createDefaultDBConnection(self::$pdo, $GLOBALS['DB_DBNAME']);
        }

        return $this->conn;
    }
}
?>]]></programlisting>
      <para>
        データベースの設定情報を切り替えてテストスイートを実行するには、
        コマンドラインから次のようにします。
      </para>
      <screen><userinput>user@desktop> phpunit --configuration developer-a.xml MyTests/</userinput>
<userinput>user@desktop> phpunit --configuration developer-b.xml MyTests/</userinput></screen>
      <para>
        データベースのテストを実行するときにターゲットデータベースを切り替えられるようにしておくことは、
        開発機で作業をしている場合などは特に重要です。
        複数の開発者が同じデータベース接続を使ってデータベースのテストを実行したりすると、
        レースコンディション (競合条件) によるテストの失敗が頻発するでしょう。
      </para>
    </section>
  </section>
  <section id="database.understanding-datasets-and-datatables">
    <title>データセットとデータテーブルについて知る</title>
    <para>
      PHPUnit Database Extension の中心となる概念が
      データセットとデータテーブルです。まずはこの考え方を理解することが、
      PHPUnit でのデータベースのテストをマスターする近道です。
      データセットとデータテーブルは、データベースのテーブルや行、
      そしてカラムの抽象化レイヤーです。シンプルな API
      によってデータベースの内容をオブジェクト構造に隠蔽できるだけでなく、
      データベース以外のソースによる実装もできるようになっています。
    </para>
    <para>
      この抽象化を使って、データベースの実際の中身と我々が期待する内容を比較します。
      期待する内容は XML や YAML そして CSV などのファイルでも表せますし、
      PHP の配列として表すこともできます。
      DataSet インターフェイスと DataTable インターフェイスのおかげで、
      これらの全く異なる概念のソースをリレーショナルデータベースに見立てて
      同様に扱えるようになります。
    </para>
    <para>
      データベースのアサーションをテストの中で行う流れは、
      次のようにシンプルな三段階となります。
    </para>
    <itemizedlist>
      <listitem>
        <para>
          ひとつあるいは複数のテーブルをデータベース内から指定する
          (実際のデータセット)。
        </para>
      </listitem>
      <listitem>
        <para>
          期待するデータセットをお好みのフォーマット (YAML, XML など)
          で用意する。
        </para>
      </listitem>
      <listitem>
        <para>
          両者がお互いに等しいことを確認する。
        </para>
      </listitem>
    </itemizedlist>
    <para>
      データセットやデータテーブルの
      PHPUnit Database Extension における使い道は、
      何もアサーションだけだというわけではありません。先ほどの節で見たように、
      これらを使ってデータベースの初期状態の内容を記述することもできます。
      フィクスチャとなるデータセットを Database TestCase
      で定義すると、それをこのように使うことができます。
    </para>
    <itemizedlist>
      <listitem>
        <para>
          データセットで指定したテーブルのすべての行を削除する。
        </para>
      </listitem>
      <listitem>
        <para>
          データテーブルのすべての行をデータベースに書き込む。
        </para>
      </listitem>
    </itemizedlist>
    <section id="database.available-implementations">
      <title>利用できる実装</title>
      <para>
        これら三種類のデータセット/データテーブルが用意されています。
      </para>
      <itemizedlist>
        <listitem>
          <para>
            ファイルベースのデータセットやデータテーブル
          </para>
        </listitem>
        <listitem>
          <para>
            クエリベースのデータセットやデータテーブル
          </para>
        </listitem>
        <listitem>
          <para>
            フィルタ用や合成用のデータセットやデータテーブル
          </para>
        </listitem>
      </itemizedlist>
      <para>
        ファイルベースのデータセットやデータテーブルは、
        初期状態のフィクスチャを定義したり期待する状態を定義したりするときによく使います。
      </para>
      <section id="database.flat-xml-dataset">
        <title>フラット XML データセット</title>
        <para>
          最も一般的なデータセットは、フラット XML と呼ばれるものです。
          これは非常にシンプルな xml 形式で、ルートノード
          <literal><![CDATA[<dataset>]]></literal>
          の中のタグがデータベースのひとつの行を表します。
          テーブルと同じ名前のタグが追加する行を表し、
          その属性がカラムを表します。
          単純な掲示板アプリケーションの例は、このようになります。
        </para>
        <screen><![CDATA[
<?xml version="1.0" ?>
<dataset>
    <guestbook id="1" content="Hello buddy!" user="joe" created="2010-04-24 17:15:23" />
    <guestbook id="2" content="I like it!" user="nancy" created="2010-04-26 12:14:20" />
</dataset>
]]></screen>
        <para>
          見るからに書きやすそうですね。この場合は
          <literal><![CDATA[<guestbook>]]></literal> がテーブル名で、
          2 行が追加されます。そして、四つのカラム <quote>id</quote>、
          <quote>content</quote>、<quote>user</quote> そして
          <quote>created</quote> に、それぞれ対応する値が設定されています。
        </para>
        <para>
          しかし、この単純性による問題もあります。
        </para>
        <para>
          たとえば、先ほどの例で空のテーブルはどうやって指定すればいいのかがよくわかりません。
          実は、何も属性を指定せずにテーブルと同じ名前のタグを追加すれば、空のテーブルを表すことができます。
          空の guestbook テーブルを表すフラット xml ファイルは、このようになります。
        </para>
        <screen><![CDATA[
<?xml version="1.0" ?>
<dataset>
    <guestbook />
</dataset>
]]></screen>
        <para>
          フラット xml データセットでの NULL 値の処理は、あまりおもしろいものではありません。
          ほとんどのデータベースでは、NULL 値と空文字列は別のものとして扱います
          (例外のひとつは Oracle です) が、これをフラット xml
          形式で表すのは困難です。NULL 値を表すには、
          行の指定のときに属性を省略します。
          この例の掲示板で、匿名の投稿を許可し、そのときには
          user カラムに NULL を指定することにしましょう。
          guestbook テーブルの状態は、このようになります。
        </para>
        <screen><![CDATA[
<?xml version="1.0" ?>
<dataset>
    <guestbook id="1" content="Hello buddy!" user="joe" created="2010-04-24 17:15:23" />
    <guestbook id="2" content="I like it!" created="2010-04-26 12:14:20" />
</dataset>
]]></screen>
        <para>
          この例では、二番目のエントリが匿名の投稿を表します。
          しかし、これはカラムの認識において深刻な問題につながります。
          データセットが等しいことを確認するアサーションでは、各データセットでテーブルの持つカラムを指定しなければなりません。
          ある属性がデータテーブルのすべての行で NULL だったなら、
          Database Extension はそのカラムがテーブルに存在することをどうやって知るというのでしょう?
        </para>
        <para>
          フラット XML データセットはここで、重大な前提を使っています。
          テーブルの最初の行で定義されている属性が、そのテーブルのカラムを定義しているものと見なすのです。
          先ほどの例では、guestbook テーブルのカラムが
          <quote>id</quote> と <quote>content</quote>、<quote>user</quote> そして
          <quote>created</quote> であると見なすということです。二番目の行には
          <quote>user</quote> が定義されていないので、データベースには
          NULL を挿入します。
        </para>
        <para>
          guestbook の最初のエントリをデータセットから削除すると、guestbook テーブルのカラムは
          <quote>id</quote>、<quote>content</quote> そして
          <quote>created</quote> だけになってしまいます。
          <quote>user</quote> が指定されていないからです。
        </para>
        <para>
          フラット XML データセットを効率的に使うには、NULL 値がからむ場合は
          各テーブルの最初の行には NULL を含まないようにします。
          それ以降の行では、属性を省略して NULL を表すことができます。
          これはあまりスマートなやり方ではありません。
          というのも、データベースのアサーションで行の順番が影響してしまうからです。
        </para>
        <para>
          一方、テーブルのカラムの一部だけをフラット XML データセットで指定すると、
          それ以外のカラムにはデフォルト値が設定されます。
          そのため、もし省略したカラムの定義が
          <quote>NOT NULL DEFAULT NULL</quote>
          などの場合はエラーになります。
        </para>
        <para>
          結論として言えるのは、フラット XML データセットを使うなら
          NULL 値が不要な場合だけにしておいたほうがよい、ということだけです。
        </para>
        <para>
          フラット XML データセットのインスタンスを
          Database TestCase から作るには、
          <literal>createFlatXmlDataSet($filename)</literal> メソッドを使います。
        </para>
        <programlisting><![CDATA[<?php
class MyTestCase extends PHPUnit_Extensions_Database_TestCase
{
    public function getDataSet()
    {
        return $this->createFlatXmlDataSet('myFlatXmlFixture.xml');
    }
}
?>]]></programlisting>
      </section>
      <section id="database.xml-dataset">
        <title>XML データセット</title>
        <para>
          もうひとつ別の構造の XML データセットもあります。これは多少冗長な書き方ですが、
          フラット XML データセットにおける NULL の問題は発生しません。
          ルートノード <literal><![CDATA[<dataset>]]></literal> の配下に指定できるタグは、
          <literal><![CDATA[<table>]]></literal> や
          <literal><![CDATA[<column>]]></literal>、<literal><![CDATA[<row>]]></literal>、
          <literal><![CDATA[<value>]]></literal> そして
          <literal><![CDATA[<null />]]></literal> です。
          先に定義した Guestbook のフラット XML と同様のデータセットは、このようになります。
        </para>
        <screen><![CDATA[
<?xml version="1.0" ?>
<dataset>
    <table name="guestbook">
        <column>id</column>
        <column>content</column>
        <column>user</column>
        <column>created</column>
        <row>
            <value>1</value>
            <value>Hello buddy!</value>
            <value>joe</value>
            <value>2010-04-24 17:15:23</value>
        </row>
        <row>
            <value>2</value>
            <value>I like it!</value>
            <null />
            <value>2010-04-26 12:14:20</value>
        </row>
    </table>
</dataset>
]]></screen>
        <para>
          <literal><![CDATA[<table>]]></literal> には name が必須で、
          さらにすべてのカラムの名前を定義しなければなりません。
          また、ゼロ個以上の <literal><![CDATA[<row>]]></literal>
          要素を含めることができます。<literal><![CDATA[<row>]]></literal>
          要素を定義しなければ、そのテーブルが空であることになります。
          <literal><![CDATA[<value>]]></literal> タグや
          <literal><![CDATA[<null />]]></literal> タグは、先に指定した
          <literal><![CDATA[column>]]></literal> 要素の順番で指定しなければなりません。
          <literal><![CDATA[<null />]]></literal> タグは、
          見た目の通り、値が NULL であることを表します。
        </para>
        <para>
          XML データセットのインスタンスを
          Database TestCase から作るには、
          <literal>createXmlDataSet($filename)</literal> メソッドを使います。
        </para>
        <programlisting><![CDATA[<?php
class MyTestCase extends PHPUnit_Extensions_Database_TestCase
{
    public function getDataSet()
    {
        return $this->createXMLDataSet('myXmlFixture.xml');
    }
}
?>]]></programlisting>
      </section>
      <section id="database.mysql-xml-dataset">
        <title>MySQL XML データセット</title>
        <para>
          この新しい XML フォーマットは、
          <ulink url="http://www.mysql.com">MySQL データベース</ulink> 専用です。
          PHPUnit 3.5 以降で対応します。この形式のファイルを生成するには、
          <ulink url="http://dev.mysql.com/doc/refman/5.0/en/mysqldump.html"><literal>mysqldump</literal></ulink>
          を使います。<literal>mysqldump</literal> では CSV データセットも対応していますが、
          それとは違ってこの XML 形式の場合はひとつのファイルに複数のテーブルを含めることができます。
          この形式のファイルを作るには、
          <literal>mysqldump</literal> を次のように実行します。
        </para>
        <screen><userinput>mysqldump --xml -t -u [username] --password=[password] [database] > /path/to/file.xml</userinput></screen>
        <para>
          このファイルを Database TestCase で使うには、
          <literal>createMySQLXMLDataSet($filename)</literal> メソッドをコールします。
        </para>
        <programlisting><![CDATA[<?php
class MyTestCase extends PHPUnit_Extensions_Database_TestCase
{
    public function getDataSet()
    {
        return $this->createMySQLXMLDataSet('/path/to/file.xml');
    }
}
?>]]></programlisting>
      </section>
      <section id="database.yaml-dataset">
        <title>YAML データセット</title>
        <para>
          あるいは、YAML データセットを使って、guestbook の例をこのように表すこともできます。
        </para>
        <screen><![CDATA[
guestbook:
  -
    id: 1
    content: "Hello buddy!"
    user: "joe"
    created: 2010-04-24 17:15:23
  -
    id: 2
    content: "I like it!"
    user:
    created: 2010-04-26 12:14:20
]]></screen>
        <para>
          これは、シンプルで便利なうえに、さらにフラット XML
          データセットが持つ NULL の問題も解決しています。
          NULL を YAML で表すには、単にカラム名の後に何も値を指定しなければよいのです。
          空文字列を指定する場合は
          <literal><![CDATA[column1: ""]]></literal>
          のようにします。
        </para>
        <para>
          YAML Dataset 用のファクトリーメソッドは今のところ Database TestCase
          に存在しないので、手動でインスタンスを生成しなければなりません。
        </para>
        <programlisting><![CDATA[<?php
class YamlGuestbookTest extends PHPUnit_Extensions_Database_TestCase
{
    protected function getDataSet()
    {
        return new PHPUnit_Extensions_Database_DataSet_YamlDataSet(
            dirname(__FILE__)."/_files/guestbook.yml"
        );
    }
}
?>]]></programlisting>
      </section>
      <section id="database.csv-dataset">
        <title>CSV データセット</title>
        <para>
          さらにもうひとつのファイルベースのデータセットとして、CSV
          ファイルを使ったものもあります。データセット内の各テーブルを、
          それぞれ単一の CSV ファイルとして扱います。
          guestbook の例では、このようなファイル
          guestbook-table.csv を定義します。
        </para>
        <screen><![CDATA[
id,content,user,created
1,"Hello buddy!","joe","2010-04-24 17:15:23"
2,"I like it!","nancy","2010-04-26 12:14:20"
]]></screen>
        <para>
          この形式は Excel や OpenOffice で編集できるという点で非常に便利ですが、
          CSV データセットでは NULL 値を指定することができません。
          空のカラムは、データベースのデフォルトに基づいた空の値として扱われます。
        </para>
        <para>
          CSV データセットを作るには、このようにします。
        </para>
        <programlisting><![CDATA[<?php
class CsvGuestbookTest extends PHPUnit_Extensions_Database_TestCase
{
    protected function getDataSet()
    {
        $dataSet = new PHPUnit_Extensions_Database_DataSet_CsvDataSet();
        $dataSet->addTable('guestbook', dirname(__FILE__)."/_files/guestbook.csv");
        return $dataSet;
    }
}
?>]]></programlisting>
      </section>
      <section id="database.array-dataset">
        <title>Array データセット</title>
        <para>
          PHPUnit の Database Extension には、(今のところ)
          配列ベースのデータセットが存在しません。しかし、自分で簡単に実装できます。
          guestbook の例だと、このようになります。
        </para>
        <programlisting><![CDATA[<?php
class ArrayGuestbookTest extends PHPUnit_Extensions_Database_TestCase
{
    protected function getDataSet()
    {
        return new MyApp_DbUnit_ArrayDataSet(array(
            'guestbook' => array(
                array('id' => 1, 'content' => 'Hello buddy!', 'user' => 'joe', 'created' => '2010-04-24 17:15:23'),
                array('id' => 2, 'content' => 'I like it!',   'user' => null,  'created' => '2010-04-26 12:14:20'),
            ),
        ));
    }
}
?>]]></programlisting>
        <para>
          PHP の DataSet には、これまでのファイルベースのデータセットに比べて明らかな利点があります。
        </para>
        <itemizedlist>
          <listitem>
            <para>
              PHP の配列は <literal>NULL</literal> 値を扱える。
            </para>
          </listitem>
          <listitem>
            <para>
              アサーション用に新たなファイルを用意する必要がなく、
              直接テストケース内で指定できる。
            </para>
          </listitem>
        </itemizedlist>
        <para>
          このデータセットでは、フラット XML や CSV そして YAML
          データセットと同様に、最初に指定した行のキーがテーブルのカラム名を表します。
          つまり、先ほどの例だと <quote>id</quote>、
          <quote>content</quote>、<quote>user</quote> そして
          <quote>created</quote> です。
        </para>
        <para>
          この Array データセットの実装は、シンプルで直感的なものです。
        </para>
        <programlisting><![CDATA[<?php
class MyApp_DbUnit_ArrayDataSet extends PHPUnit_Extensions_Database_DataSet_AbstractDataSet
{
    /**
     * @var array
     */
    protected $tables = array();

    /**
     * @param array $data
     */
    public function __construct(array $data)
    {
        foreach ($data AS $tableName => $rows) {
            $columns = array();
            if (isset($rows[0])) {
                $columns = array_keys($rows[0]);
            }

            $metaData = new PHPUnit_Extensions_Database_DataSet_DefaultTableMetaData($tableName, $columns);
            $table = new PHPUnit_Extensions_Database_DataSet_DefaultTable($metaData);

            foreach ($rows AS $row) {
                $table->addRow($row);
            }
            $this->tables[$tableName] = $table;
        }
    }

    protected function createIterator($reverse = FALSE)
    {
        return new PHPUnit_Extensions_Database_DataSet_DefaultTableIterator($this->tables, $reverse);
    }

    public function getTable($tableName)
    {
        if (!isset($this->tables[$tableName])) {
            throw new InvalidArgumentException("$tableName is not a table in the current database.");
        }

        return $this->tables[$tableName];
    }
}
?>]]></programlisting>
      </section>
      <section id="database.query-sql-dataset">
        <title>Query (SQL) データセット</title>
        <para>
          データベースのアサーションでは、ファイルベースのデータセットだけでなく
          Query/SQL ベースのデータセットでデータベースの実際の中身を含むものが必要になることもあります。
          そんなときに使えるのが Query データセットです。
        </para>
        <programlisting><![CDATA[<?php
$ds = new PHPUnit_Extensions_Database_DataSet_QueryDataSet($this->getConnection());
$ds->addTable('guestbook');
?>]]></programlisting>
        <para>
          単にテーブル名だけを指定してテーブルを追加すると、
          次のクエリを実行してデータテーブルを定義したのと同じ意味になります。
        </para>
        <programlisting><![CDATA[<?php
$ds = new PHPUnit_Extensions_Database_DataSet_QueryDataSet($this->getConnection());
$ds->addTable('guestbook', 'SELECT * FROM guestbook');
?>]]></programlisting>
        <para>
          ここでテーブルに対して任意のクエリを実行して、
          取得する行や列を絞り込んだり
          <literal>ORDER BY</literal> 句を追加したりすることができます。
        </para>
        <programlisting><![CDATA[<?php
$ds = new PHPUnit_Extensions_Database_DataSet_QueryDataSet($this->getConnection());
$ds->addTable('guestbook', 'SELECT id, content FROM guestbook ORDER BY created DESC');
?>]]></programlisting>
        <para>
          データベースアサーションの節で、このデータセットを使う方法をより詳しく説明しています。
        </para>
      </section>
      <section id="database.database-db-dataset">
        <title>Database (DB) データセット</title>
        <para>
          テスト用のデータベース接続にアクセスすると、
          自動的にすべてのテーブルとその中身を含むデータセットを生成します。
          接続先のデータベースは、接続用のファクトリーメソッドの二番目のパラメータで指定します。
        </para>
        <para>
          データベース全体の完全なデータセットを作るには
          <literal>testGuestbook()</literal> のようにします。
          ホワイトリスト形式で指定したテーブルだけに絞り込むには
          <literal>testFilteredGuestbook()</literal> メソッドのようにします。
        </para>
        <programlisting><![CDATA[<?php
class MySqlGuestbookTest extends PHPUnit_Extensions_Database_TestCase
{
    /**
     * @return PHPUnit_Extensions_Database_DB_IDatabaseConnection
     */
    public function getConnection()
    {
        $database = 'my_database';
        $pdo = new PDO('mysql:...', $user, $password);
        return $this->createDefaultDBConnection($pdo, $database);
    }

    public function testGuestbook()
    {
        $dataSet = $this->getConnection()->createDataSet();
        // ...
    }

    public function testFilteredGuestbook()
    {
        $tableNames = array('guestbook');
        $dataSet = $this->getConnection()->createDataSet($tableNames);
        // ...
    }
}
?>]]></programlisting>
      </section>
      <section id="database.replacement-dataset">
        <title>Replacement データセット</title>
        <para>
          これまで、フラット XML や CSV のデータセットには NULL
          の問題があると説明してきました。
          しかし、ちょっとわかりにくい回避策を使えばこれらのデータセットで
          NULL を扱うこともできます。
        </para>
        <para>
          Replacement データセットは既存のデータセットに対するデコレータで、
          データセットの任意のカラムの値を別の値で置換することができます。
          guestbook の例で NULL 値を扱うには、このようなファイルを作ります。
        </para>
        <screen><![CDATA[
<?xml version="1.0" ?>
<dataset>
    <guestbook id="1" content="Hello buddy!" user="joe" created="2010-04-24 17:15:23" />
    <guestbook id="2" content="I like it!" user="##NULL##" created="2010-04-26 12:14:20" />
</dataset>
]]></screen>
        <para>
          そして、フラット XML データセットを Replacement データセットでラップします。
        </para>
        <programlisting><![CDATA[<?php
class ReplacementTest extends PHPUnit_Extensions_Database_TestCase
{
    public function getDataSet()
    {
        $ds = $this->createFlatXmlDataSet('myFlatXmlFixture.xml');
        $rds = new PHPUnit_Extensions_Database_DataSet_ReplacementDataSet($ds);
        $rds->addFullReplacement('##NULL##', null);
        return $rds;
    }
}
?>]]></programlisting>
      </section>
      <section id="database.dataset-filter">
        <title>データセットフィルタ</title>
        <para>
          巨大なフィクスチャファイルを扱うときには、
          データセットフィルタをホワイトリストあるいはブラックリストとして使って
          テーブルやカラムを絞り込んだサブデータセットを作ることができます。
          これは、DB データセットと組み合わせて
          データセットのカラムを絞り込むときに使うと非常に便利です。
        </para>
        <programlisting><![CDATA[<?php
class DataSetFilterTest extends PHPUnit_Extensions_Database_TestCase
{
    public function testIncludeFilteredGuestbook()
    {
        $tableNames = array('guestbook');
        $dataSet = $this->getConnection()->createDataSet();

        $filterDataSet = new PHPUnit_Extensions_Database_DataSet_DataSetFilter($dataSet);
        $filterDataSet->addIncludeTables(array('guestbook'));
        $filterDataSet->setIncludeColumnsForTable('guestbook', array('id', 'content'));
        // ..
    }

    public function testExcludeFilteredGuestbook()
    {
        $tableNames = array('guestbook');
        $dataSet = $this->getConnection()->createDataSet();

        $filterDataSet = new PHPUnit_Extensions_Database_DataSet_DataSetFilter($dataSet);
        $filterDataSet->addExcludeTables(array('foo', 'bar', 'baz')); // only keep the guestbook table!
        $filterDataSet->setExcludeColumnsForTable('guestbook', array('user', 'created'));
        // ..
    }
}
?>]]></programlisting>
        <blockquote>
          <para>
            <emphasis role="strong">注意</emphasis>
            ひとつのテーブルに対してカラムの exclude フィルタと
            include フィルタを同時に使うことはできません。
            さらに、テーブルのホワイトリストとブラックリストはどちらか一方しか指定できません。
          </para>
        </blockquote>
      </section>
      <section id="database.composite-dataset">
        <title>Composite データセット</title>
        <para>
          Composite データセットは、既存の複数のデータセットをひとつにまとめるときに有用です。
          複数のデータセットに同名のテーブルが含まれる場合は、
          指定した順で行を連結します。
          たとえば、このようなふたつのデータセットがあるものとしましょう。
          まずは <emphasis>fixture1.xml</emphasis>。
        </para>
        <screen><![CDATA[
<?xml version="1.0" ?>
<dataset>
    <guestbook id="1" content="Hello buddy!" user="joe" created="2010-04-24 17:15:23" />
</dataset>
]]></screen>
        <para>
          そして <emphasis>fixture2.xml</emphasis>。
        </para>
        <screen><![CDATA[
<?xml version="1.0" ?>
<dataset>
    <guestbook id="2" content="I like it!" user="##NULL##" created="2010-04-26 12:14:20" />
</dataset>
]]></screen>
        <para>
          Composite データセットを使えば、両方のフィクスチャファイルをまとめることができます。
        </para>
        <programlisting><![CDATA[<?php
class CompositeTest extends PHPUnit_Extensions_Database_TestCase
{
    public function getDataSet()
    {
        $ds1 = $this->createFlatXmlDataSet('fixture1.xml');
        $ds2 = $this->createFlatXmlDataSet('fixture2.xml');

        $compositeDs = new PHPUnit_Extensions_Database_DataSet_CompositeDataSet();
        $compositeDs->addDataSet($ds1);
        $compositeDs->addDataSet($ds2);

        return $compositeDs;
    }
}
?>]]></programlisting>
      </section>
    </section>
    <section id="database.beware-of-foreign-keys">
      <title>外部キーには注意</title>
      <para>
        フィクスチャを準備するとき、PHPUnit の Database Extension
        はフィクスチャ内で定義された順に行を追加していきます。
        データベースのスキーマ定義で外部キーを使っている場合は、
        外部キー制約に違反しないような順番でテーブルを指定しなければなりません。
      </para>
    </section>
    <section id="database.implementing-your-own-datasetsdatatables">
      <title>自作のデータセットやデータテーブルの実装</title>
      <para>
        データセットやデータテーブルの内部構造を理解するために、
        まずはデータセットのインターフェイスから見ていきましょう。
        自分でデータセットやデータテーブルを作るつもりのない人は、
        読み飛ばしてもかまいません。
      </para>
      <programlisting><![CDATA[<?php
interface PHPUnit_Extensions_Database_DataSet_IDataSet extends IteratorAggregate
{
    public function getTableNames();
    public function getTableMetaData($tableName);
    public function getTable($tableName);
    public function assertEquals(PHPUnit_Extensions_Database_DataSet_IDataSet $other);

    public function getReverseIterator();
}
?>]]></programlisting>
      <para>
        公開インターフェイスは、データベーステストケースの
        <literal>assertDataSetsEqual()</literal>
        アサーションで内部的に使われており、これでデータセットの内容を検証します。
        IDataSet は <literal>IteratorAggregate</literal>
        インターフェイスから <literal>getIterator()</literal>
        メソッドを継承しており、これを使ってデータセット内の全テーブルの反復処理を行います。
        リバースイテレータを使うと、PHPUnit で作ったテーブルのデータの切り詰めを、
        テーブルを作ったときと逆の順番で行えます。これで、外部キー制約に違反せずに済むようになります。
      </para>
      <para>
        テーブルのインスタンスをデータセットに追加するには、
        実装によってさまざまな手法があります。たとえば
        <literal>YamlDataSet</literal> や
        <literal>XmlDataSet</literal> そして <literal>FlatXmlDataSet</literal>
        のようなファイルベースのデータセットでは、
        データセットの作成時にソースファイルを使って内部的に追加します。
      </para>
      <para>
        テーブルは、このようなインターフェイスを使って表します。
      </para>
      <programlisting><![CDATA[<?php
interface PHPUnit_Extensions_Database_DataSet_ITable
{
    public function getTableMetaData();
    public function getRowCount();
    public function getValue($row, $column);
    public function getRow($row);
    public function assertEquals(PHPUnit_Extensions_Database_DataSet_ITable $other);
}
?>]]></programlisting>
      <para>
        <literal>getTableMetaData()</literal> メソッドは別として、
        それ以外のメソッドはまさに文字通りの働きをするものです。
        これらのメソッドはすべて、Database Extension のさまざまなアサーションで必須となります。
        その詳細は次の章で説明します。
        <literal>getTableMetaData()</literal> メソッドの返す値は、
        <literal>PHPUnit_Extensions_Database_DataSet_ITableMetaData</literal>
        インターフェイスを実装したものでなければなりません。
        このインターフェイスはテーブルの構造を表し、このような情報を保持します。
      </para>
      <itemizedlist>
        <listitem>
          <para>
            テーブル名。
          </para>
        </listitem>
        <listitem>
          <para>
            テーブルのカラム名の配列。並び順は、結果セットに登場する順と同じ。
          </para>
        </listitem>
        <listitem>
          <para>
            主キーカラムの配列。
          </para>
        </listitem>
      </itemizedlist>
      <para>
        このインターフェイスには、ふたつの TableMetaData
        のインスタンスがお互いに等しいかを調べるアサーションも定義されています。
        これは、データセットの同一性を調べるアサーションで利用するものです。
      </para>
    </section>
  </section>
  <section id="database.the-connection-api">
    <title>接続 API</title>
    <para>
      Connection インターフェイスには、三種類のおもしろいメソッドが用意されています。
      このインターフェイスは、データベーステストケースの
      <literal>getConnection()</literal> メソッドが返すものです。
    </para>
    <programlisting><![CDATA[<?php
interface PHPUnit_Extensions_Database_DB_IDatabaseConnection
{
    public function createDataSet(Array $tableNames = NULL);
    public function createQueryTable($resultName, $sql);
    public function getRowCount($tableName, $whereClause = NULL);

    // ...
}
?>]]></programlisting>
    <orderedlist numeration="arabic">
      <listitem>
        <para>
          <literal>createDataSet()</literal> メソッドは、Database
          (DB) データセットを作ります。これは、データセットの実装の節で説明したものです。
        </para>
        <programlisting><![CDATA[<?php
class ConnectionTest extends PHPUnit_Extensions_Database_TestCase
{
    public function testCreateDataSet()
    {
        $tableNames = array('guestbook');
        $dataSet = $this->getConnection()->createDataSet();
    }
}
?>]]></programlisting>
      </listitem>
      <listitem>
        <para>
          <literal>createQueryTable()</literal> メソッドを使うと、
          QuryTable のインスタンスを作れます。引数には、結果の名前と SQL クエリを渡します。
          これは、次の節 (データベースアサーション API)
          で説明する結果やテーブルのアサーションで有用なメソッドです。
        </para>
        <programlisting><![CDATA[<?php
class ConnectionTest extends PHPUnit_Extensions_Database_TestCase
{
    public function testCreateQueryTable()
    {
        $tableNames = array('guestbook');
        $queryTable = $this->getConnection()->createQueryTable('guestbook', 'SELECT * FROM guestbook');
    }
}
?>]]></programlisting>
      </listitem>
      <listitem>
        <para>
          <literal>getRowCount()</literal> は、
          テーブル内の行数を手軽に取得するためのメソッドです。
          オプションで、where 句によるフィルタリングもできます。
          これを使えば、シンプルな同一性のアサーションが可能です。
        </para>
        <programlisting><![CDATA[<?php
class ConnectionTest extends PHPUnit_Extensions_Database_TestCase
{
    public function testGetRowCount()
    {
        $this->assertEquals(2, $this->getConnection()->getRowCount('guestbook'));
    }
}
?>]]></programlisting>
      </listitem>
    </orderedlist>
  </section>
  <section id="database.database-assertions-api">
    <title>データベースアサーション API</title>
    <para>
      テストツール用として、Database Extension ではいくつかのアサーションを提供しています。
      これらを使えば、データベースやテーブルの現在の状態
      そしてテーブルの行数を検証できます。この節では、
      これらの機能の詳細を説明します。
    </para>
    <section id="database.asserting-the-row-count-of-a-table">
      <title>テーブルの行数のアサーション</title>
      <para>
        テーブルの行数が特定の値であるかどうかを調べられれば便利なことがよくあります。
        これは、接続 API を使ってちょっとしたコードを書かなくとも簡単に実現できます。
        guestbook に行を追加した後で、初期登録した 2 エントリ以外にもう一行増えて
        3 行になっていることを調べるには、このようにします。
      </para>
      <programlisting><![CDATA[<?php
class GuestbookTest extends PHPUnit_Extensions_Database_TestCase
{
    public function testAddEntry()
    {
        $this->assertEquals(2, $this->getConnection()->getRowCount('guestbook'), "Pre-Condition");

        $guestbook = new Guestbook();
        $guestbook->addEntry("suzy", "Hello world!");

        $this->assertEquals(3, $this->getConnection()->getRowCount('guestbook'), "Inserting failed");
    }
}
?>]]></programlisting>
    </section>
    <section id="database.asserting-the-state-of-a-table">
      <title>テーブルの状態のアサーション</title>
      <para>
        先ほどのアサーションも有用ですが、本当にチェックしたいのは、
        すべての値が正しいカラムにきちんと登録されたかどうかです。
        これは、テーブルのアサーションで実現します。
      </para>
      <para>
        そのために、QueryTable のインスタンスを定義しました。
        テーブル名と SQL クエリからその内容を取得し、
        それをファイルベースあるいは配列ベースのデータセットと比較します。
      </para>
      <programlisting><![CDATA[<?php
class GuestbookTest extends PHPUnit_Extensions_Database_TestCase
{
    public function testAddEntry()
    {
        $guestbook = new Guestbook();
        $guestbook->addEntry("suzy", "Hello world!");

        $queryTable = $this->getConnection()->createQueryTable(
            'guestbook', 'SELECT * FROM guestbook'
        );
        $expectedTable = $this->createFlatXmlDataSet("expectedBook.xml")
                              ->getTable("guestbook");
        $this->assertTablesEqual($expectedTable, $queryTable);
    }
}
?>]]></programlisting>
      <para>
        さて次に、このアサーションに使うフラット XML ファイル
        <emphasis>expectedBook.xml</emphasis> を用意しましょう。
      </para>
      <screen><![CDATA[
<?xml version="1.0" ?>
<dataset>
    <guestbook id="1" content="Hello buddy!" user="joe" created="2010-04-24 17:15:23" />
    <guestbook id="2" content="I like it!" user="nancy" created="2010-04-26 12:14:20" />
    <guestbook id="3" content="Hello world!" user="suzy" created="2010-05-01 21:47:08" />
</dataset>
]]></screen>
      <para>
        残念ながら、このアサーションが成功するのは、ちょうど
        <emphasis>2010–05–01 21:47:08</emphasis> に実行したときだけになります。
        日付はデータベースのテストでいつも問題になるものなので、それを回避する手段として
        <quote>created</quote> カラムをアサーションで無視させることができます。
      </para>
      <para>
        調整後のフラット XML ファイル <emphasis>expectedBook.xml</emphasis>
        はこのようになり、これでアサーションを通過させることができます。
      </para>
      <screen><![CDATA[
<?xml version="1.0" ?>
<dataset>
    <guestbook id="1" content="Hello buddy!" user="joe" />
    <guestbook id="2" content="I like it!" user="nancy" />
    <guestbook id="3" content="Hello world!" user="suzy" />
</dataset>
]]></screen>
      <para>
        QueryTable の呼び出しも修正しなければなりません。
      </para>
      <programlisting><![CDATA[<?php
$queryTable = $this->getConnection()->createQueryTable(
    'guestbook', 'SELECT id, content, user FROM guestbook'
);
?>]]></programlisting>
    </section>
    <section id="database.asserting-the-result-of-a-query">
      <title>クエリの結果のアサーション</title>
      <para>
        複雑なクエリの結果に対するアサーションも、
        QueryTable 方式で可能です。単に結果の名前とクエリを指定して、
        それをデータセットと比較すればよいのです。
      </para>
      <programlisting><![CDATA[<?php
class ComplexQueryTest extends PHPUnit_Extensions_Database_TestCase
{
    public function testComplexQuery()
    {
        $queryTable = $this->getConnection()->createQueryTable(
            'myComplexQuery', 'SELECT complexQuery...'
        );
        $expectedTable = $this->createFlatXmlDataSet("complexQueryAssertion.xml")
                              ->getTable("myComplexQuery");
        $this->assertTablesEqual($expectedTable, $queryTable);
    }
}
?>]]></programlisting>
    </section>
    <section id="database.asserting-the-state-of-multiple-tables">
      <title>複数のテーブルの状態のアサーション</title>
      <para>
        もちろん、複数のテーブルの状態を一度に確かめたり
        クエリデータセットをファイルベースのデータセットと比較したりすることも可能です。
        データセットのアサーションには二通りの方法があります。
      </para>
      <orderedlist numeration="arabic">
        <listitem>
          <para>
            接続の Database (DB) データセットを使い、
            それをファイルベースのデータセットと比較する。
          </para>
          <programlisting><![CDATA[<?php
class DataSetAssertionsTest extends PHPUnit_Extensions_Database_TestCase
{
    public function testCreateDataSetAssertion()
    {
        $dataSet = $this->getConnection()->createDataSet(array('guestbook'));
        $expectedDataSet = $this->createFlatXmlDataSet('guestbook.xml');
        $this->assertDataSetsEqual($expectedDataSet, $dataSet);
    }
}
?>]]></programlisting>
        </listitem>
        <listitem>
          <para>
            データセットを自分で作ることもできます。
          </para>
          <programlisting><![CDATA[<?php
class DataSetAssertionsTest extends PHPUnit_Extensions_Database_TestCase
{
    public function testManualDataSetAssertion()
    {
        $dataSet = new PHPUnit_Extensions_Database_DataSet_QueryDataSet();
        $dataSet->addTable('guestbook', 'SELECT id, content, user FROM guestbook'); // additional tables
        $expectedDataSet = $this->createFlatXmlDataSet('guestbook.xml');

        $this->assertDataSetsEqual($expectedDataSet, $dataSet);
    }
}
?>]]></programlisting>
        </listitem>
      </orderedlist>
    </section>
  </section>
  <section id="database.frequently-asked-questions">
    <title>よくある質問</title>
    <section id="database.will-phpunit-re-create-the-database-schema-for-each-test">
      <title>PHPUnit は、テストごとにデータベーススキーマを作り直すの?</title>
      <para>
        いいえ。PHPUnit は、テストスイートの開始時にすべてのデータベースオブジェクトが存在することを前提とします。
        データベースやテーブル、シーケンス、トリガー、そしてビューなどは、
        テストスイートを実行する前に作っておく必要があります。
      </para>
      <para>
        <ulink url="http://www.doctrine-project.org">Doctrine 2</ulink> や
        <ulink url="http://www.ezcomponents.org">eZ Components</ulink>
        の強力なツールを使えば、定義済みのデータ構造からデータベーススキーマを作成できます。
        しかし、これらを使うには PHPUnit extension にフックで組み込まねばなりません。
        そうしないと、テストスイートを実行する前にデータベースの自動再作成ができなくなります。
      </para>
      <para>
        各テストの実行後はデータベースをクリアするので、
        テストを実行するたびにデータベースを再作成する必要はありません。
        事前に作ったデータベースをずっと使いまわすことができます。
      </para>
    </section>
    <section id="database.am-i-required-to-use-pdo-in-my-application-for-the-database-extension-to-work">
      <title>PDO を使ったアプリケーションじゃないと Database Extension を使えないの?</title>
      <para>
        いいえ。PDO が必要なのは、フィクスチャの準備や後始末とアサーションのときだけです。
        テスト対象のコード内では、なんでもお好みの方法でデータベースにアクセスできます。
      </para>
    </section>
    <section id="database.what-can-i-do-when-i-get-a-too-much-connections-error">
      <title><quote>Too much Connections</quote> というエラーが出たらどうすればいい?</title>
      <para>
        テストケースの <literal>getConnection()</literal> メソッドで作った
        PDO インスタンスをキャッシュしていなければ、
        データベースを使うテストを実行するたびにデータベースへの接続の数は増加し続けます。
        デフォルトの設定では MySQL が受け付ける同時接続は 100 までであり、
        他のデータベースにも同様の接続数制限があります。
      </para>
      <para>
        <quote>自前でのデータベーステストケースの抽象化</quote>
        に、このエラーを回避する方法を示しています。
        ひとつの PDO インスタンスをキャッシュして、すべてのテストで使いまわす方法です。
      </para>
    </section>
    <section id="database.how-to-handle-null-with-flat-xml-csv-datasets">
      <title>フラット XML や CSV のデータセットで NULL を扱う方法は?</title>
      <para>
        そんな方法はありません。NULL が使いたければ XML あるいは YAML データセットを使わないといけません。
      </para>
    </section>
  </section>
</chapter>

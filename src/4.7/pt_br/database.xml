<?xml version="1.0" encoding="utf-8" ?>

<chapter id="database">
  <title>Testando Bancos de Dados</title>
  <para>
    Muitos exemplos de testes unitários iniciantes e intermediários em qualquer linguagem de 
    programação sugerem que é perfeitamente fácil testar a lógica de sua aplicação 
    com testes simples. Para aplicações centradas em bancos de dados isso está longe 
    da realidade. Comece a usar Wordpress, TYPO3 ou Symfony com Doctrine ou Propel, 
    por exemplo, e você vai experimentar facilmente problemas consideráveis com o 
    PHPUnit: apenas porque o banco de dados é fortemente acoplado com essas bibliotecas.
  </para>
  <para>
    Você provavelmente conhece esse cenário dos seus trabalhos e projetos diários, 
    onde você quer colocar em prática suas habilidades (novas ou não) com PHPUnit 
    e acaba ficando preso por um dos seguintes problemas:
  </para>
  <orderedlist numeration="arabic">
    <listitem>
      <para>
        O método que você quer testar executa uma operação JOIN muito grande e 
        usa os dados para calcular alguns resultados importantes.
      </para>
    </listitem>
    <listitem>
      <para>
        Sua lógica de negócios faz uma mistura de declarações SELECT, INSERT, UPDATE 
        e DELETE.
      </para>
    </listitem>
    <listitem>
      <para>
        Você precisa definir os dados de teste em (provavelmente muito) mais de duas tabelas 
        para conseguir dados iniciais razoáveis para os métodos que deseja testar.
      </para>
    </listitem>
  </orderedlist>
  <para>
    A extensão DbUnit simplifica consideravelmente a configuração de um banco de dados 
    para fins de teste e permite a você verificar os conteúdos de um banco de dados após 
    fazer uma série de operações.
  </para>
  <section id="database.supported-vendors-for-database-testing">
    <title>Fornecedores Suportados para Testes de Banco de Dados</title>
    <para>
      DbUnit atualmente suporta MySQL, PostgreSQL, Oracle e SQLite. Através 
      das integrações <ulink url="http://framework.zend.com">Zend Framework</ulink> ou
      <ulink url="http://www.doctrine-project.org">Doctrine 2</ulink>
      ele tem acesso a outros sistemas como IBM DB2 ou 
      Microsoft SQL Server.
    </para>
  </section>
  <section id="database.difficulties-in-database-testing">
    <title>Dificuldades em Testes de Bancos de Dados</title>
    <para>
      Existe uma boa razão pela qual todos os exemplos de testes unitários não incluírem 
      interações com bancos de dados: esses tipos de testes são complexos tanto em 
      configuração quanto em manutenção. Enquanto testar contra seu banco de dados você 
      precisará ter cuidado com as seguintes variáveis:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          Esquema e tabelas do banco de dados
        </para>
      </listitem>
      <listitem>
        <para>
          Inserção das linhas exigidas para o teste nessas tabelas
        </para>
      </listitem>
      <listitem>
        <para>
          Verificação do estado do banco de dados depois de executar os testes
        </para>
      </listitem>
      <listitem>
        <para>
          Limpeza do banco de dados para cada novo teste
        </para>
      </listitem>
    </itemizedlist>
    <para>
      Por causa de muitas APIs de bancos de dados como PDO, MySQLi ou OCI8 serem incômodos 
      de usar e verbosas para escrever, fazer esses passos manualmente é um completo 
      pesadelo.
    </para>
    <para>
      O código de teste deve ser o mais curto e preciso possível por várias razões:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          Você não quer modificar uma considerável quantidade de código de teste por 
          pequenas mudanças em seu código de produção.
        </para>
      </listitem>
      <listitem>
        <para>
          Você quer ser capaz de ler e entender o código de teste facilmente, 
          mesmo meses depois de tê-lo escrito.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      Adicionalmente você tem que perceber que o banco de dados é essencialmente 
      uma variável global de entrada para seu código. Dois testes em sua suíte de testes 
      podem executar contra o mesmo banco de dados, possivelmente reutilizando dados 
      múltiplas vezes. Falhas em um teste podem facilmente afetar o resultado dos 
      testes seguintes, fazendo sua experiência com os testes muito difícil. O 
      passo de limpeza mencionado anteriormente é de maior importância 
      para resolver o problema do <quote>banco de dados ser uma entrada global</quote>.
    </para>
    <para>
      DbUnit ajuda a simplificar todos esses problemas com testes de bancos de dados de uma
      forma elegante.
    </para>
    <para>
      O PHPUnit só não pode ajudá-lo no fato de que testes de banco de dados 
      são muito lentos comparados aos testes que não usam bancos de dados. Dependendo 
      do tamanho das interações com seu banco de dados, seus testes 
      podem levar um tempo considerável para executar. Porém se você mantiver pequena 
      a quantidade de dados usados para cada teste e tentar testar o máximo possível 
      sem usar testes com bancos de dados, você facilmente conseguirá tempos abaixo de um minuto, 
      mesmo para grandes suítes de teste.
    </para>
    <para>
      A suíte de testes do <ulink url="http://www.doctrine-project.org">projeto 
      Doctrine 2</ulink> por exemplo, atualmente tem uma suíte com 
      cerca de 1000 testes onde aproximadamente a metade deles tem acesso ao banco 
      de dados e ainda executa em 15 segundos contra um banco de dados MySQL em 
      um computador desktop comum.
    </para>
  </section>
  <section id="database.the-four-stages-of-a-database-test">
    <title>Os quatro estágios dos testes com banco de dados</title>
    <para>
      Em seu livro sobre Padrões de Teste xUnit, Gerard Meszaros lista os quatro 
      estágios de um teste unitário:
    </para>
    <orderedlist numeration="arabic">
      <listitem>
        <para>
          Configurar o ambiente (fixture)
        </para>
      </listitem>
      <listitem>
        <para>
          Exercitar o Sistema Sob Teste
        </para>
      </listitem>
      <listitem>
        <para>
          Verificar o resultado
        </para>
      </listitem>
      <listitem>
        <para>
          Desmontagem (Teardown)
        </para>
      </listitem>
    </orderedlist>
    <blockquote>
      <para>
        <emphasis role="strong">O que é um ambiente (fixture)?</emphasis>
      </para>
      <para>
        Um ambiente (fixture) descreve o estado inicial em que sua aplicação e seu banco de dados 
        estão ao executar um teste.
      </para>
    </blockquote>
    <para>
      Testar o banco de dados exige que você utilize pelo menos o 
      setup (configuração) e teardown (desmontagem) para limpar e escrever em suas tabelas 
      os dados de ambiente exigidos. Porém a extensão do banco de dados tem uma boa razão para 
      reverter esses quatro estágios em um teste de banco de dados para assemelhar o seguinte 
      fluxo de trabalho que é executado para cada teste:
    </para>
    <section id="database.clean-up-database">
      <title>1. Limpar o Banco de Dados</title>
      <para>
        Já que sempre existe um primeiro teste que é executado contra o banco de dados, 
        você não sabe exatamente se já existem dados nas tabelas. 
        O PHPUnit vai executar um TRUNCATE contra todas as tabelas que 
        você especificou para redefinir seus estados para vazio.
      </para>
    </section>
    <section id="database.set-up-fixture">
      <title>2. Configurar o ambiente</title>
      <para>
        O PHPUnit então vai iterar sobre todas as linhas do ambiente especificado e 
        inseri-las em suas respectivas tabelas.
      </para>
    </section>
    <section id="database.run-test-verify-outcome-and-teardown">
      <title>3–5. Executar Teste, Verificar resultado e Desmontar (Teardown)</title>
      <para>
        Depois de redefinir o banco de dados e carregá-lo com seu estado inicial, 
        o verdadeiro teste é executado pelo PHPUnit. Esta parte do código de teste 
        não exige conhecimento sobre a Extensão do Banco de Dados, então você pode 
        prosseguir e testar o que quiser com seu código.
      </para>
      <para>
        Em seu teste use uma asserção especial chamada
        <literal>assertDataSetsEqual()</literal> para fins de verificação, 
        porém isso é totalmente opcional. Esta função será explicada 
        na seção <quote>Asserções em Bancos de Dados</quote>.
      </para>
    </section>
  </section>
  <section id="database.configuration-of-a-phpunit-database-testcase">
    <title>Configuração de um Caso de Teste de Banco de Dados do PHPUnit</title>
    <para>
      Ao usar o PHPUnit seus casos de teste vão estender a 
      classe <literal>PHPUnit_Framework_TestCase</literal> da 
      seguinte forma:
    </para>
    <programlisting><![CDATA[<?php
class MyTest extends PHPUnit_Framework_TestCase
{
    public function testCalculate()
    {
        $this->assertEquals(2, 1 + 1);
    }
}
?>]]></programlisting>
    <para>
      Se você quer um código de teste que trabalha com a Extensão para Banco de Dados a 
      configuração é um pouco mais complexa e você terá que estender um TestCase abstrato 
      diferente, exigindo que você implemente dois métodos abstratos
      <literal>getConnection()</literal> e
      <literal>getDataSet()</literal>:
    </para>
    <programlisting><![CDATA[<?php
class MyGuestbookTest extends PHPUnit_Extensions_Database_TestCase
{
    /**
     * @return PHPUnit_Extensions_Database_DB_IDatabaseConnection
     */
    public function getConnection()
    {
        $pdo = new PDO('sqlite::memory:');
        return $this->createDefaultDBConnection($pdo, ':memory:');
    }

    /**
     * @return PHPUnit_Extensions_Database_DataSet_IDataSet
     */
    public function getDataSet()
    {
        return $this->createFlatXMLDataSet(dirname(__FILE__).'/_files/guestbook-seed.xml');
    }
}
?>]]></programlisting>
    <section id="database.implementing-getconnection">
      <title>Implementando getConnection()</title>
      <para>
        Para permitir que a limpeza e o carregamento de funcionalidades do ambiente funcionem, 
        a Extensão do Banco de Dados do PHPUnit exige acesso a uma conexão 
        abstrata do banco de dados através dos fornecedores da biblioteca PDO. É 
        importante notar que sua aplicação não precisa ser 
        baseada em PDO para usar a Extensão para Banco de Dados do PHPUnit, pois a conexão é 
        meramente usada para limpeza e configuração de ambiente.
      </para>
      <para>
        No exemplo anterior criamos uma conexão Sqlite na memória e 
        a passamos ao método <literal>createDefaultDBConnection</literal>
        que embrulha a instância do PDO e o segundo parâmetro (o 
        nome do banco de dados) em uma camada simples de abstração para conexões 
        do banco de dados do tipo
        <literal>PHPUnit_Extensions_Database_DB_IDatabaseConnection</literal>.
      </para>
      <para>
        A seção <quote>Usando a Conexão de Banco de Dados</quote> explica 
        a API desta interface e como você pode usá-la da melhor forma possível.
      </para>
    </section>
    <section id="database.implementing-getdataset">
      <title>Implementando getDataSet()</title>
      <para>
        O método <literal>getDataSet()</literal> define como deve ser o estado 
        inicial do banco de dados antes de cada teste ser 
        executado. O estado do banco de dados é abstraído através de 
        conceitos DataSet (Conjunto de Dados) e DataTable (Tabela de Dados), ambos sendo representados 
        pelas interfaces
        <literal>PHPUnit_Extensions_Database_DataSet_IDataSet</literal> e
        <literal>PHPUnit_Extensions_Database_DataSet_IDataTable</literal>.
        A próxima seção vai descrever em detalhes como esses conceitos trabalham 
        e quais os benefícios de usá-los nos testes com bancos de dados.
      </para>
      <para>
        Para a implementação precisaremos apenas saber que o 
        método <literal>getDataSet()</literal> é chamado uma vez durante o
        <literal>setUp()</literal> para recuperar o conjunto de dados do ambiente e 
        inseri-lo no banco de dados. No exemplo estamos usando um método de fábrica 
        <literal>createFlatXMLDataSet($filename)</literal> que 
        representa um conjunto de dados através de uma representação XML.
      </para>
    </section>
    <section id="database.what-about-the-database-schema-ddl">
      <title>E quanto ao Esquema do Banco de Dados (DDL)?</title>
      <para>
        O PHPUnit assume que o esquema do banco de dados com todas as suas tabelas, 
        gatilhos, sequências e visualizações é criado antes que um teste seja executado. Isso 
        quer dizer que você como desenvolvedor deve se certificar que o banco de dados está 
        corretamente configurado antes de executar a suíte.
      </para>
      <para>
        Existem vários meios para realizar esta pré-condição para 
        testar bancos de dados.
      </para>
      <orderedlist numeration="arabic">
        <listitem>
          <para>
            Se você está usando um banco de dados persistente (não Sqlite Memory) você pode 
            facilmente configurar o banco de dados uma vez com ferramentas como phpMyAdmin para 
            MySQL e reutilizar o banco de dados para cada execução de teste.
          </para>
        </listitem>
        <listitem>
          <para>
            Se você estiver usando bibliotecas como
            <ulink url="http://www.doctrine-project.org">Doctrine 2</ulink> ou
            <ulink url="http://www.propelorm.org/">Propel</ulink>
            você pode usar suas APIs para criar o esquema de banco de dados que 
            precisa antes de rodar os testes. Você pode utilizar as capacidades de 
            <ulink url="textui.html">Configuração e Bootstrap do PHPUnit</ulink>
            para executar esse código sempre que seus testes forem executados.
          </para>
        </listitem>
      </orderedlist>
    </section>
    <section id="database.tip-use-your-own-abstract-database-testcase">
      <title>Dica: Use seu próprio Caso Abstrato de Teste de Banco de Dados</title>
      <para>
        Do exemplo prévio de implementação você pode facilmente perceber que 
        o método <literal>getConnection()</literal> é bastante estático e 
        pode ser reutilizado em diferentes casos de teste de banco de dados. Adicionalmente para 
        manter uma boa performance dos seus testes e pouca carga sobre seu banco de dados, você 
        pode refatorar o código um pouco para obter um caso de teste abstrato genérico 
        para sua aplicação, o que ainda permite a você especificar um 
        ambiente de dados diferente para cada caso de teste:
      </para>
      <programlisting><![CDATA[<?php
abstract class MyApp_Tests_DatabaseTestCase extends PHPUnit_Extensions_Database_TestCase
{
    // only instantiate pdo once for test clean-up/fixture load
    static private $pdo = null;

    // only instantiate PHPUnit_Extensions_Database_DB_IDatabaseConnection once per test
    private $conn = null;

    final public function getConnection()
    {
        if ($this->conn === null) {
            if (self::$pdo == null) {
                self::$pdo = new PDO('sqlite::memory:');
            }
            $this->conn = $this->createDefaultDBConnection(self::$pdo, ':memory:');
        }

        return $this->conn;
    }
}
?>]]></programlisting>
      <para>
        Entretanto, isso tem a conexão ao banco de dados codificada na conexão do PDO. 
        O PHPUnit tem outra incrível característica que pode fazer este 
        caso de teste ainda mais genérico. Se você usar a
        <ulink url="appendixes.configuration.html#appendixes.configuration.php-ini-constants-variables">Configuração XML</ulink>
        você pode tornar a conexão com o banco de dados configurável por execução de teste. 
        Primeiro vamos criar um arquivo <quote>phpunit.xml</quote> em nosso diretório/de/teste 
        da aplicação, de forma semelhante a isto:
      </para>
      <screen><![CDATA[
<?xml version="1.0" encoding="UTF-8" ?>
<phpunit>
    <php>
        <var name="DB_DSN" value="mysql:dbname=myguestbook;host=localhost" />
        <var name="DB_USER" value="user" />
        <var name="DB_PASSWD" value="passwd" />
        <var name="DB_DBNAME" value="myguestbook" />
    </php>
</phpunit>
]]></screen>
      <para>
        Agora podemos modificar seu caso de teste para parecer com isso:
      </para>
      <programlisting><![CDATA[<?php
abstract class Generic_Tests_DatabaseTestCase extends PHPUnit_Extensions_Database_TestCase
{
    // only instantiate pdo once for test clean-up/fixture load
    static private $pdo = null;

    // only instantiate PHPUnit_Extensions_Database_DB_IDatabaseConnection once per test
    private $conn = null;

    final public function getConnection()
    {
        if ($this->conn === null) {
            if (self::$pdo == null) {
                self::$pdo = new PDO( $GLOBALS['DB_DSN'], $GLOBALS['DB_USER'], $GLOBALS['DB_PASSWD'] );
            }
            $this->conn = $this->createDefaultDBConnection(self::$pdo, $GLOBALS['DB_DBNAME']);
        }

        return $this->conn;
    }
}
?>]]></programlisting>
      <para>
        Agora podemos executar a suíte de testes de banco de dados usando diferentes 
        configurações através da interface de linha-de-comando:
      </para>
      <screen><userinput>user@desktop> phpunit --configuration developer-a.xml MyTests/</userinput>
<userinput>user@desktop> phpunit --configuration developer-b.xml MyTests/</userinput></screen>
      <para>
        A possibilidade de executar facilmente os testes de banco de dados contra diferentes 
        alvos é muito importante se você está desenvolvendo na 
        máquina de desenvolvimento. Se vários desenvolvedores executarem os testes de banco 
        de dados contra a mesma conexão de banco de dados você experimentará facilmente 
        falhas de testes devido à condição de execução.
      </para>
    </section>
  </section>
  <section id="database.understanding-datasets-and-datatables">
    <title>Entendendo Conjunto de Dados e Tabelas de Dados</title>
    <para>
      Um conceito central da Extensão para Banco de Dados do PHPUnit são 
      os Conjuntos de Dados e as Tabelas de Dados. Você deveria tentar entender este conceito simples para 
      dominar os testes de banco de dados com PHPUnit. Conjunto de Dados e Tabela de Dados formam 
      uma camada abstrata em torno das tabelas, linhas e 
      colunas do seu banco de dados. Uma simples API esconde os conteúdos subjacentes do banco de dados em uma 
      estrutura de objetos, que também podem ser implementada por outra 
      fonte que não seja um banco de dados.
    </para>
    <para>
      Essa abstração é necessária para comparar os conteúdos reais de um 
      banco de dados contra os conteúdos esperados. Expectativas podem ser 
      representadas como arquivos XML, YAML, CSV ou vetores PHP, por exemplo. As 
      interfaces DataSet (Conjunto de Dados) e DataTable (Tabela de Dados)  permitem a comparação dessas 
      fontes conceitualmente diferentes, emulando o armazenamento de banco de dados 
      relacional em uma abordagem semanticamente similar.
    </para>
    <para>
      Um fluxo de trabalho para asserções em banco de dados em seus testes então consiste de 
      três passos simples:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          Especificar uma ou mais tabelas em seu banco de dados por nome de tabela (conjunto de dados 
          real)
        </para>
      </listitem>
      <listitem>
        <para>
          Especificar o Conjunto de Dados esperado no seu formato preferido (YAML, XML, 
          ...)
        </para>
      </listitem>
      <listitem>
        <para>
          Asseverar que ambas as representações de conjunto de dados se equivalem.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      Asserções não são o único caso de uso para o Conjunto de Dados e a Tabela de Dados 
      na Extensão para Banco de Dados do PHPUnit. Como mostrado na seção anterior, 
      eles também descrevem os conteúdos iniciais de um banco de dados. Você é 
      forçado a definir um conjunto de dados de ambiente pelo Caso de Teste de Banco de Dados, que 
      então é usado para:
    </para>
    <itemizedlist>
      <listitem>
        <para>
          Deletar todas as linhas das tabelas especificadas no conjunto de dados.
        </para>
      </listitem>
      <listitem>
        <para>
          Escrever todas as linhas nas tabelas de dados do banco de dados.
        </para>
      </listitem>
    </itemizedlist>
    <section id="database.available-implementations">
      <title>Implementações disponíveis</title>
      <para>
        Existem três tipos diferentes de conjuntos de dados/tabelas de dados:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            Conjuntos de Dados e Tabelas de Dados baseados em arquivo
          </para>
        </listitem>
        <listitem>
          <para>
            Conjuntos de Dados e Tabelas de Dados baseados em query
          </para>
        </listitem>
        <listitem>
          <para>
            Filtro e Composição de Conjunto de Dados e Tabelas de Dados
          </para>
        </listitem>
      </itemizedlist>
      <para>
        Os Conjuntos de Dados e Tabelas de Dados baseadas em arquivo são geralmente usados para o 
        ambiente inicial e para descrever os estados esperados do banco de dados.
      </para>
      <section id="database.flat-xml-dataset">
        <title>Conjunto de Dados de XML Plano</title>
        <para>
          O Conjunto de Dados mais comum é chamado XML Plano. É um formato xml simples 
          onde uma tag dentro do nó-raiz
          <literal><![CDATA[<dataset>]]></literal> representa exatamente uma linha no 
          banco de dados. Os nomes das tags equivalem à tabela onde inserir a linha e 
          um atributo representa a coluna. Um exemplo para uma simples aplicação de 
          livro de visitas poderia se parecer com isto:
        </para>
        <screen><![CDATA[
<?xml version="1.0" ?>
<dataset>
    <guestbook id="1" content="Hello buddy!" user="joe" created="2010-04-24 17:15:23" />
    <guestbook id="2" content="I like it!" user="nancy" created="2010-04-26 12:14:20" />
</dataset>
]]></screen>
        <para>
          Isso é, obviamente, fácil de escrever. Aqui
          <literal><![CDATA[<guestbook>]]></literal> é o nome da tabela onde duas linhas 
          são inseridas dentro de cada com quatro colunas <quote>id</quote>,
          <quote>content</quote>, <quote>user</quote> e
          <quote>created</quote> com seus respectivos valores.
        </para>
        <para>
          Porém essa simplicidade tem um preço.
        </para>
        <para>
          O exemplo anterior não deixa tão óbvio como você pode fazer para especificar uma 
          tabela vazia. Você pode inserir uma tag sem atributos com o nome da 
          tabela vazia. Um arquivo xml plano para uma tabela vazia do livro de visitas 
          ficaria parecido com isso:
        </para>
        <screen><![CDATA[
<?xml version="1.0" ?>
<dataset>
    <guestbook />
</dataset>
]]></screen>
        <para>
          A manipulação de valores NULL com o xml plano é tedioso. Um 
          valor NULL é diferente de uma string com valor vazio em quase todos 
          os bancos de dados (Oracle é uma exceção), algo difícil 
          de descrever no formato xml plano. Você pode representar um valor NULL 
          omitindo o atributo da especificação da linha. Se nosso 
          livro de visitas vai permitir entradas anônimas representadas por um valor NULL 
          na coluna user, um estado hipotético para a tabela do livro de visitas 
          seria parecido com:
        </para>
        <screen><![CDATA[
<?xml version="1.0" ?>
<dataset>
    <guestbook id="1" content="Hello buddy!" user="joe" created="2010-04-24 17:15:23" />
    <guestbook id="2" content="I like it!" created="2010-04-26 12:14:20" />
</dataset>
]]></screen>
        <para>
          Nesse caso a segunda entrada é postada anonimamente. Porém isso 
          acarreta um problema sério no reconhecimento de colunas. Durante as asserções de igualdade 
          do conjunto de dados, cada conjunto de dados tem que especificar quais colunas uma 
          tabela possui. Se um atributo for NULL para todas as linhas de uma 
          tabela de dados, como a Extensão para Banco de Dados vai saber que a coluna 
          deve ser parte da tabela?
        </para>
        <para>
          O conjunto de dados em xml plano faz uma presunção crucial agora, definindo que 
          os atributos na primeira linha definida de uma tabela define as 
          colunas dessa tabela. No exemplo anterior isso significaria que
          <quote>id</quote>, <quote>content</quote>, <quote>user</quote> e
          <quote>created</quote> são colunas da tabela guestbook. Para a 
          segunda linha, onde <quote>user</quote> não está definido, um NULL seria 
          inserido no banco de dados.
        </para>
        <para>
          Quando a primeira entrada do guestbook for apagada do conjunto de dados, apenas
          <quote>id</quote>, <quote>content</quote> e
          <quote>created</quote> seriam colunas da tabela guestbook, 
          já que <quote>user</quote> não é especificado.
        </para>
        <para>
          Para usar o Conjunto de Dados em XML Plano efetivamente, quando valores NULL forem 
          relevantes, a primeira linha de cada tabela não deve conter qualquer valor NULL 
          e apenas as linhas seguintes poderão omitir atributos. Isso 
          pode parecer estranho, já que a ordem das linhas é um fator relevante 
          para as asserções com bancos de dados.
        </para>
        <para>
          Em troca, se você especificar apenas um subconjunto das colunas da tabela no 
          Conjunto de Dados do XML Plano, todos os valores omitidos serão definidos para seus valores 
          padrão. Isso vai induzir a erros se uma das colunas omitidas estiver 
          definida como <quote>NOT NULL DEFAULT NULL</quote>.
        </para>
        <para>
          Para concluir eu posso dizer que os conjuntos de dados XML Plano só devem ser usadas se você 
          não precisar de valores NULL.
        </para>
        <para>
          Você pode criar uma instância de conjunto de dados xml plano de dentro de seu 
          Caso de Teste de Banco de Dados chamando o método
          <literal>createFlatXmlDataSet($filename)</literal>:
        </para>
        <programlisting><![CDATA[<?php
class MyTestCase extends PHPUnit_Extensions_Database_TestCase
{
    public function getDataSet()
    {
        return $this->createFlatXmlDataSet('myFlatXmlFixture.xml');
    }
}
?>]]></programlisting>
      </section>
      <section id="database.xml-dataset">
        <title>Conjunto de Dados XML</title>
        <para>
          Existe um outro Conjunto de Dados em XML mais estruturado, que é um pouco mais 
          verboso para escrever mas evita os problemas do NULL nos conjuntos de dados em 
          XML Plano. Dentro do nó-raiz <literal><![CDATA[<dataset>]]></literal> você 
          pode especificar as tags <literal><![CDATA[<table>]]></literal>,
          <literal><![CDATA[<column>]]></literal>, <literal><![CDATA[<row>]]></literal>,
          <literal><![CDATA[<value>]]></literal> e
          <literal><![CDATA[<null />]]></literal>. Um Conjunto de Dados equivalente ao 
          definido anteriormente no Guestbook em XML Plano seria como:
        </para>
        <screen><![CDATA[
<?xml version="1.0" ?>
<dataset>
    <table name="guestbook">
        <column>id</column>
        <column>content</column>
        <column>user</column>
        <column>created</column>
        <row>
            <value>1</value>
            <value>Hello buddy!</value>
            <value>joe</value>
            <value>2010-04-24 17:15:23</value>
        </row>
        <row>
            <value>2</value>
            <value>I like it!</value>
            <null />
            <value>2010-04-26 12:14:20</value>
        </row>
    </table>
</dataset>
]]></screen>
        <para>
          Qualquer <literal><![CDATA[<table>]]></literal> definida tem um nome e requer 
          uma definição de todas as colunas com seus nomes. Pode conter zero 
          ou qualquer número positivo de elementos <literal><![CDATA[<row>]]></literal> 
          aninhados. Não definir nenhum elemento <literal><![CDATA[<row>]]></literal> significa 
          que a tabela está vazia. As tags <literal><![CDATA[<value>]]></literal> e
          <literal><![CDATA[<null />]]></literal> têm que ser especificadas na 
          ordem dos elementos fornecidos previamente em 
          <literal><![CDATA[<column>]]></literal>. A tag <literal><![CDATA[<null />]]></literal> obviamente significa 
          que o valor é NULL.
        </para>
        <para>
          Você pode criar uma instância de conjunto de dados xml de dentro de seu 
          Caso de Teste de Banco de Dados chamando o método 
          <literal>createXmlDataSet($filename)</literal>:
        </para>
        <programlisting><![CDATA[<?php
class MyTestCase extends PHPUnit_Extensions_Database_TestCase
{
    public function getDataSet()
    {
        return $this->createXMLDataSet('myXmlFixture.xml');
    }
}
?>]]></programlisting>
      </section>
      <section id="database.mysql-xml-dataset">
        <title>Conjunto de Dados XML MySQL</title>
        <para>
          Este novo formato XML é específico para o
          <ulink url="http://www.mysql.com">servidor de banco de dados MySQL</ulink>.
          O suporte para ele foi adicionado no PHPUnit 3.5. Arquivos nesse formato podem 
          ser gerados usando o utilitário 
          <ulink url="http://dev.mysql.com/doc/refman/5.0/en/mysqldump.html"><literal>mysqldump</literal></ulink>. 
          Diferente dos conjuntos de dados CSV, que o <literal>mysqldump</literal>
          também suporta, um único arquivo neste formato XML pode conter dados 
          para múltiplas tabelas. Você pode criar um arquivo nesse formato 
          invocando o <literal>mysqldump</literal> desta forma:
        </para>
        <screen><userinput>mysqldump --xml -t -u [username] --password=[password] [database] > /path/to/file.xml</userinput></screen>
        <para>
          Esse arquivo pode ser usado em seu Caso de Teste de Banco de Dados chamando o método
          <literal>createMySQLXMLDataSet($filename)</literal>:
        </para>
        <programlisting><![CDATA[<?php
class MyTestCase extends PHPUnit_Extensions_Database_TestCase
{
    public function getDataSet()
    {
        return $this->createMySQLXMLDataSet('/path/to/file.xml');
    }
}
?>]]></programlisting>
      </section>
      <section id="database.yaml-dataset">
        <title>Conjunto de Dados YAML</title>
        <para>
          Alternativamente, você pode usar o Conjunto de dados YAML para o exemplo guestbook:
        </para>
        <screen><![CDATA[
guestbook:
  -
    id: 1
    content: "Hello buddy!"
    user: "joe"
    created: 2010-04-24 17:15:23
  -
    id: 2
    content: "I like it!"
    user:
    created: 2010-04-26 12:14:20
]]></screen>
        <para>
          Isso é simples, conveniente E resolve o problema do NULL que o 
          Conjunto de Dados similar do XML Plano tem. Um NULL em um YAML é apenas o nome 
          da coluna sem nenhum valor especificado. Uma string vazia é especificada como
          <literal><![CDATA[column1: ""]]></literal>.
        </para>
        <para>
          O Conjunto de Dados YAML atualmente não possui método fábrica no Caso de Teste 
          de Banco de Dados, então você tem que instanciar manualmente:
        </para>
        <programlisting><![CDATA[<?php
class YamlGuestbookTest extends PHPUnit_Extensions_Database_TestCase
{
    protected function getDataSet()
    {
        return new PHPUnit_Extensions_Database_DataSet_YamlDataSet(
            dirname(__FILE__)."/_files/guestbook.yml"
        );
    }
}
?>]]></programlisting>
      </section>
      <section id="database.csv-dataset">
        <title>Conjunto de Dados CSV</title>
        <para>
          Outro Conjunto de Dados baseado em arquivo, com arquivos CSV. Cada tabela do 
          conjunto de dados é representada como um único arquivo CSV. Para nosso exemplo 
          do guestbook, vamos definir um arquivo guestbook-table.csv:
        </para>
        <screen><![CDATA[
id,content,user,created
1,"Hello buddy!","joe","2010-04-24 17:15:23"
2,"I like it!","nancy","2010-04-26 12:14:20"
]]></screen>
        <para>
          Apesar disso ser muito conveniente para edição no Excel ou OpenOffice, 
          você não pode especificar valores NULL em um Conjunto de Dados CSV. Uma coluna 
          vazia levaria a um valor vazio padrão de banco de dados a ser inserido 
          na coluna.
        </para>
        <para>
          Você pode criar um Conjunto de Dados CSV chamando:
        </para>
        <programlisting><![CDATA[<?php
class CsvGuestbookTest extends PHPUnit_Extensions_Database_TestCase
{
    protected function getDataSet()
    {
        $dataSet = new PHPUnit_Extensions_Database_DataSet_CsvDataSet();
        $dataSet->addTable('guestbook', dirname(__FILE__)."/_files/guestbook.csv");
        return $dataSet;
    }
}
?>]]></programlisting>
      </section>
      <section id="database.array-dataset">
        <title>Conjunto de Dados em Vetor</title>
        <para>
          Desde a versão 1.3.2 da Extensão de Banco de dados do PHPUnit há um array 
          baseado em Conjunto de dados. Nosso exemplo do guestbook 
          deveria ficar parecido com:
        </para>
        <programlisting><![CDATA[<?php
class ArrayGuestbookTest extends PHPUnit_Extensions_Database_TestCase
{
    protected function getDataSet()
    {
        return $this->createArrayDataSet(array(
            'guestbook' => array(
                array('id' => 1, 'content' => 'Hello buddy!', 'user' => 'joe', 'created' => '2010-04-24 17:15:23'),
                array('id' => 2, 'content' => 'I like it!',   'user' => null,  'created' => '2010-04-26 12:14:20'),
            ),
        ));
    }
}
?>]]></programlisting>
        <para>
          Um Conjunto de Dados do PHP tem algumas vantagens óbvias sobre todas os outros 
          conjuntos de dados baseados em arquivos:
        </para>
        <itemizedlist>
          <listitem>
            <para>
              Vetores PHP podem, obviamente, trabalhar com valores <literal>NULL</literal>.
            </para>
          </listitem>
          <listitem>
            <para>
              Você não precisa de arquivos adicionais para asserções e pode especificá-las diretamente 
              no Caso de Teste.
            </para>
          </listitem>
        </itemizedlist>
        <para>
          Para este Conjunto de Dados, como nos Conjuntos de Dados em XML Plano, CSV e YAML, as chaves 
          da primeira linha especificada definem os nomes das colunas das tabelas, que no 
          caso anterior seriam <quote>id</quote>,
          <quote>content</quote>, <quote>user</quote> e
          <quote>created</quote>.
        </para>
      </section>
      <section id="database.query-sql-dataset">
        <title>Conjunto de Dados Query (SQL)</title>
        <para>
          Para asserções de banco de dados você não precisa somente de conjuntos de dados baseados em arquivos, 
          mas também de conjuntos de dados baseados em Query/SQL que contenha os conteúdos 
          reais do banco de dados. É aí que entra o Query DataSet:
        </para>
        <programlisting><![CDATA[<?php
$ds = new PHPUnit_Extensions_Database_DataSet_QueryDataSet($this->getConnection());
$ds->addTable('guestbook');
?>]]></programlisting>
        <para>
          Adicionar uma tabela apenas por nome é um modo implícito de definir a 
          tabela de dados com a seguinte query:
        </para>
        <programlisting><![CDATA[<?php
$ds = new PHPUnit_Extensions_Database_DataSet_QueryDataSet($this->getConnection());
$ds->addTable('guestbook', 'SELECT * FROM guestbook');
?>]]></programlisting>
        <para>
          Você pode fazer uso disso especificando queries arbitrárias para suas 
          tabelas, por exemplo restringindo linhas, colunas, ou adicionando 
          cláusulas <literal>ORDER BY</literal>:
        </para>
        <programlisting><![CDATA[<?php
$ds = new PHPUnit_Extensions_Database_DataSet_QueryDataSet($this->getConnection());
$ds->addTable('guestbook', 'SELECT id, content FROM guestbook ORDER BY created DESC');
?>]]></programlisting>
        <para>
          A seção nas Asserções de Banco de Dados mostrará mais alguns detalhes sobre 
          como fazer uso do Conjunto de Dados Query.
        </para>
      </section>
      <section id="database.database-db-dataset">
        <title>Conjunto de Dados de Banco de Dados (BD)</title>
        <para>
          Acessando a Conexão de Teste você pode criar automaticamente um 
          Conjunto de Dados que consiste de todas as tabelas com seus conteúdos no 
          banco de dados especificado como segundo parâmetro ao método 
          Fábrica de Conexões.
        </para>
        <para>
          Você pode tanto criar um Conjunto de Dados para todo o banco de dados como mostrado 
          em  <literal>testGuestbook()</literal>, ou restringi-lo a um conjunto de 
          nomes específicos de tabelas com uma lista branca, como mostrado no 
          método <literal>testFilteredGuestbook()</literal>.
        </para>
        <programlisting><![CDATA[<?php
class MySqlGuestbookTest extends PHPUnit_Extensions_Database_TestCase
{
    /**
     * @return PHPUnit_Extensions_Database_DB_IDatabaseConnection
     */
    public function getConnection()
    {
        $database = 'my_database';
        $user = 'my_user';
        $password = 'my_password';
        $pdo = new PDO('mysql:...', $user, $password);
        return $this->createDefaultDBConnection($pdo, $database);
    }

    public function testGuestbook()
    {
        $dataSet = $this->getConnection()->createDataSet();
        // ...
    }

    public function testFilteredGuestbook()
    {
        $tableNames = array('guestbook');
        $dataSet = $this->getConnection()->createDataSet($tableNames);
        // ...
    }
}
?>]]></programlisting>
      </section>
      <section id="database.replacement-dataset">
        <title>Conjunto de Dados de Reposição</title>
        <para>
          Eu tenho falado sobre problemas com NULL nos Conjunto de Dados XML Plano e 
          CSV, mas existe uma alternativa um pouco complicada para fazer ambos 
          funcionarem com NULLs.
        </para>
        <para>
          O Conjunto de Dados de Reposição é um decorador para um Conjunto de Dados existente e 
          permite que você substitua valores em qualquer coluna do conjunto de dados por outro 
          valor de reposição. Para fazer nosso exemplo do guestbook funcionar com valores NULL 
          devemos especificar o arquivo como:
        </para>
        <screen><![CDATA[
<?xml version="1.0" ?>
<dataset>
    <guestbook id="1" content="Hello buddy!" user="joe" created="2010-04-24 17:15:23" />
    <guestbook id="2" content="I like it!" user="##NULL##" created="2010-04-26 12:14:20" />
</dataset>
]]></screen>
        <para>
          Então envolvemos o Conjunto de Dados em XML Plano dentro de um Conjunto de Dados de Reposição:
        </para>
        <programlisting><![CDATA[<?php
class ReplacementTest extends PHPUnit_Extensions_Database_TestCase
{
    public function getDataSet()
    {
        $ds = $this->createFlatXmlDataSet('myFlatXmlFixture.xml');
        $rds = new PHPUnit_Extensions_Database_DataSet_ReplacementDataSet($ds);
        $rds->addFullReplacement('##NULL##', null);
        return $rds;
    }
}
?>]]></programlisting>
      </section>
      <section id="database.dataset-filter">
        <title>Filtro de Conjunto de Dados</title>
        <para>
          Se você tiver um arquivo grande de ambiente você pode usar o Filtro de Conjunto de Dados para 
          as listas branca e negra das tabelas e colunas que deveriam estar 
          contidas em um sub-conjunto de dados. Isso ajuda especialmente em combinação 
          com o DB DataSet para filtrar as colunas dos conjuntos de dados.
        </para>
        <programlisting><![CDATA[<?php
class DataSetFilterTest extends PHPUnit_Extensions_Database_TestCase
{
    public function testIncludeFilteredGuestbook()
    {
        $tableNames = array('guestbook');
        $dataSet = $this->getConnection()->createDataSet();

        $filterDataSet = new PHPUnit_Extensions_Database_DataSet_DataSetFilter($dataSet);
        $filterDataSet->addIncludeTables(array('guestbook'));
        $filterDataSet->setIncludeColumnsForTable('guestbook', array('id', 'content'));
        // ..
    }

    public function testExcludeFilteredGuestbook()
    {
        $tableNames = array('guestbook');
        $dataSet = $this->getConnection()->createDataSet();

        $filterDataSet = new PHPUnit_Extensions_Database_DataSet_DataSetFilter($dataSet);
        $filterDataSet->addExcludeTables(array('foo', 'bar', 'baz')); // only keep the guestbook table!
        $filterDataSet->setExcludeColumnsForTable('guestbook', array('user', 'created'));
        // ..
    }
}
?>]]></programlisting>
        <blockquote>
          <para>
            <emphasis role="strong">NOTA</emphasis> Você não pode usar ambos os 
            filtros de coluna excluir e incluir na mesma tabela, apenas em tabelas 
            diferentes. E mais: só é possível para a lista branca ou negra, 
            mas não para ambas.
          </para>
        </blockquote>
      </section>
      <section id="database.composite-dataset">
        <title>Conjunto de Dados Composto</title>
        <para>
          O Conjunto de Dados composto é muito útil para agregar vários 
          conjuntos de dados já existentes em um único Conjunto de Dados. Quando vários 
          conjuntos de dados contém as mesmas tabelas, as linhas são anexadas na 
          ordem especificada. Por exemplo se tivermos dois conjuntos de dados
          <emphasis>fixture1.xml</emphasis>:
        </para>
        <screen><![CDATA[
<?xml version="1.0" ?>
<dataset>
    <guestbook id="1" content="Hello buddy!" user="joe" created="2010-04-24 17:15:23" />
</dataset>
]]></screen>
        <para>
          e <emphasis>fixture2.xml</emphasis>:
        </para>
        <screen><![CDATA[
<?xml version="1.0" ?>
<dataset>
    <guestbook id="2" content="I like it!" user="##NULL##" created="2010-04-26 12:14:20" />
</dataset>
]]></screen>
        <para>
          Usando o Conjunto de Dados Composto podemos agregar os dois arquivos de ambiente:
        </para>
        <programlisting><![CDATA[<?php
class CompositeTest extends PHPUnit_Extensions_Database_TestCase
{
    public function getDataSet()
    {
        $ds1 = $this->createFlatXmlDataSet('fixture1.xml');
        $ds2 = $this->createFlatXmlDataSet('fixture2.xml');

        $compositeDs = new PHPUnit_Extensions_Database_DataSet_CompositeDataSet();
        $compositeDs->addDataSet($ds1);
        $compositeDs->addDataSet($ds2);

        return $compositeDs;
    }
}
?>]]></programlisting>
      </section>
    </section>
    <section id="database.beware-of-foreign-keys">
      <title>Cuidado com Chaves Estrangeiras</title>
      <para>
        Durante a Configuração do Ambiente a Extensão para Banco de Dados do PHPUnit insere as linhas 
        no banco de dados na ordem que são especificadas em seu ambiente. 
        Se seu esquema de banco de dados usa chaves estrangeiras isso significa que você tem que 
        especificar as tabelas em uma ordem que não faça as restrições das chaves estrangeiras 
        falharem.
      </para>
    </section>
    <section id="database.implementing-your-own-datasetsdatatables">
      <title>Implementando seus próprios Conjuntos de Dados/ Tabelas de Dados</title>
      <para>
        Para entender os interiores dos Conjuntos de Dados e Tabelas de Dados, vamos dar uma 
        olhada na interface de um Conjunto de Dados. Você pode pular esta parte se você 
        não planeja implementar seu próprio Conjunto de Dados ou Tabela de Dados.
      </para>
      <programlisting><![CDATA[<?php
interface PHPUnit_Extensions_Database_DataSet_IDataSet extends IteratorAggregate
{
    public function getTableNames();
    public function getTableMetaData($tableName);
    public function getTable($tableName);
    public function assertEquals(PHPUnit_Extensions_Database_DataSet_IDataSet $other);

    public function getReverseIterator();
}
?>]]></programlisting>
      <para>
        A interface pública é usada internamente pela asserção
        <literal>assertDataSetsEqual()</literal> no Caso de Teste de 
        Banco de Dados para verificar a qualidade do conjunto de dados. Da interface
        <literal>IteratorAggregate</literal> o IDataSet 
        herda o método <literal>getIterator()</literal> para iterar 
        sobre todas as tabelas do conjunto de dados. O iterador reverso permite o PHPUnit 
        truncar corretamente as tabelas em ordem reversa à que foi criada para satisfazer 
        as restrições de chaves estrangeiras.
      </para>
      <para>
        Dependendo da implementação, diferentes abordagens são usadas para 
        adicionar instâncias de tabela a um Conjunto de Dados. Por exemplo, tabelas são adicionadas 
        internamente durante a construção a partir de um arquivo fonte em todos 
        os conjuntos de dados baseados em arquivo como <literal>YamlDataSet</literal>,
        <literal>XmlDataSet</literal> ou <literal>FlatXmlDataSet</literal>.
      </para>
      <para>
        Uma tabela também é representada pela seguinte interface:
      </para>
      <programlisting><![CDATA[<?php
interface PHPUnit_Extensions_Database_DataSet_ITable
{
    public function getTableMetaData();
    public function getRowCount();
    public function getValue($row, $column);
    public function getRow($row);
    public function assertEquals(PHPUnit_Extensions_Database_DataSet_ITable $other);
}
?>]]></programlisting>
      <para>
        Com exceção do método <literal>getTableMetaData()</literal> isso é 
        bastante auto-explicativo. Os métodos usados são todos requeridos para 
        as diferentes asserções da Extensão para Banco de Dados que são 
        explicados no próximo capítulo. O método
        <literal>getTableMetaData()</literal> deve retornar uma 
        implementação da interface
        <literal>PHPUnit_Extensions_Database_DataSet_ITableMetaData</literal>
        que descreve a estrutura da tabela. Possui informações 
        sobre:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            O nome da tabela
          </para>
        </listitem>
        <listitem>
          <para>
            Um vetor de nomes de coluna da tabela, ordenado por suas aparições 
            nos conjuntos de resultados.
          </para>
        </listitem>
        <listitem>
          <para>
            Um vetor de colunas de chaves-primárias.
          </para>
        </listitem>
      </itemizedlist>
      <para>
        Essa interface também tem uma asserção que verifica se duas instâncias 
        de Metadados de Tabela se equivalem, o que é usado pela asserção de igualdade 
        do conjunto de dados.
      </para>
    </section>
  </section>
  <section id="database.the-connection-api">
    <title>A API de Conexão</title>
    <para>
      Existem três métodos interessantes na interface Connection 
      que devem ser retornados do método
      <literal>getConnection()</literal> no Caso de Teste de Banco de Dados:
    </para>
    <programlisting><![CDATA[<?php
interface PHPUnit_Extensions_Database_DB_IDatabaseConnection
{
    public function createDataSet(Array $tableNames = NULL);
    public function createQueryTable($resultName, $sql);
    public function getRowCount($tableName, $whereClause = NULL);

    // ...
}
?>]]></programlisting>
    <orderedlist numeration="arabic">
      <listitem>
        <para>
          O método <literal>createDataSet()</literal> cria um Conjunto de Dados 
          de Banco de Dados (BD) como descrito na seção de implementações de Conjunto de Dados.
        </para>
        <programlisting><![CDATA[<?php
class ConnectionTest extends PHPUnit_Extensions_Database_TestCase
{
    public function testCreateDataSet()
    {
        $tableNames = array('guestbook');
        $dataSet = $this->getConnection()->createDataSet();
    }
}
?>]]></programlisting>
      </listitem>
      <listitem>
        <para>
          O método <literal>createQueryTable()</literal> pode ser usado para 
          criar instâncias de uma QueryTable, dado um nome de resultado e uma query 
          SQL. Este é um método conveniente quando se fala sobre asserções de resultado/tabela
          como será mostrado na próxima seção de API de Asserções 
          de Banco de Dados.
        </para>
        <programlisting><![CDATA[<?php
class ConnectionTest extends PHPUnit_Extensions_Database_TestCase
{
    public function testCreateQueryTable()
    {
        $tableNames = array('guestbook');
        $queryTable = $this->getConnection()->createQueryTable('guestbook', 'SELECT * FROM guestbook');
    }
}
?>]]></programlisting>
      </listitem>
      <listitem>
        <para>
          O método <literal>getRowCount()</literal> é uma forma conveniente de 
          acessar o número de linhas em uma tabela, opcionalmente filtradas por uma 
          cláusula where adicional. Isso pode ser usado com uma simples asserção 
          de igualdade:
        </para>
        <programlisting><![CDATA[<?php
class ConnectionTest extends PHPUnit_Extensions_Database_TestCase
{
    public function testGetRowCount()
    {
        $this->assertEquals(2, $this->getConnection()->getRowCount('guestbook'));
    }
}
?>]]></programlisting>
      </listitem>
    </orderedlist>
  </section>
  <section id="database.database-assertions-api">
    <title>API de Asserções de Banco de Dados</title>
    <para>
      Para uma ferramenta de testes, a Extensão para Banco de Dados certamente fornece algumas 
      asserções que você pode usar para verificar o estado atual do banco de dados, 
      tabelas e a contagem de linhas de tabelas. Esta seção 
      descreve essa funcionalidade em detalhes:
    </para>
    <section id="database.asserting-the-row-count-of-a-table">
      <title>Asseverado a contagem de linhas de uma Tabela</title>
      <para>
        Às vezes ajuda verificar se uma tabela contém uma quantidade específica 
        de linhas. Você pode conseguir isso facilmente sem colar códigos adicionais 
        usando a API de Conexão. Suponha que queiramos verificar se após a 
        inserção de uma linha em nosso guestbook não apenas temos as duas entradas 
        iniciais que nos acompanharam em todos os exemplos 
        anteriores, mas uma terceira:
      </para>
      <programlisting><![CDATA[<?php
class GuestbookTest extends PHPUnit_Extensions_Database_TestCase
{
    public function testAddEntry()
    {
        $this->assertEquals(2, $this->getConnection()->getRowCount('guestbook'), "Pre-Condition");

        $guestbook = new Guestbook();
        $guestbook->addEntry("suzy", "Hello world!");

        $this->assertEquals(3, $this->getConnection()->getRowCount('guestbook'), "Inserting failed");
    }
}
?>]]></programlisting>
    </section>
    <section id="database.asserting-the-state-of-a-table">
      <title>Asseverando o Estado de uma Tabela</title>
      <para>
       A asserção anterior ajuda, mas certamente queremos verificar os 
        conteúdos reais da tabela para verificar se todos os valores foram 
        escritos nas colunas corretas. Isso pode ser conseguido com uma 
        asserção de tabela.
      </para>
      <para>
        Para isso vamos definir uma instância de Tabela Query que deriva seu 
        conteúdo de um nome de tabela e de uma query SQL e compara isso a um 
        Conjunto de Dados baseado em Arquivo/Vetor:
      </para>
      <programlisting><![CDATA[<?php
class GuestbookTest extends PHPUnit_Extensions_Database_TestCase
{
    public function testAddEntry()
    {
        $guestbook = new Guestbook();
        $guestbook->addEntry("suzy", "Hello world!");

        $queryTable = $this->getConnection()->createQueryTable(
            'guestbook', 'SELECT * FROM guestbook'
        );
        $expectedTable = $this->createFlatXmlDataSet("expectedBook.xml")
                              ->getTable("guestbook");
        $this->assertTablesEqual($expectedTable, $queryTable);
    }
}
?>]]></programlisting>
      <para>
        Agora temos que escrever o arquivo XML Plano <emphasis>expectedBook.xml</emphasis> 
        para esta asserção:
      </para>
      <screen><![CDATA[
<?xml version="1.0" ?>
<dataset>
    <guestbook id="1" content="Hello buddy!" user="joe" created="2010-04-24 17:15:23" />
    <guestbook id="2" content="I like it!" user="nancy" created="2010-04-26 12:14:20" />
    <guestbook id="3" content="Hello world!" user="suzy" created="2010-05-01 21:47:08" />
</dataset>
]]></screen>
      <para>
        Apesar disso, esta asserção só vai passar em exatamente um segundo 
        do universo, em <emphasis>2010–05–01 21:47:08</emphasis>. Datas 
        possuem um problema especial nos testes de bancos de dados e podemos circundar 
        a falha omitindo a coluna <quote>created</quote> 
        da asserção.
      </para>
      <para>
        O arquivo ajustado <emphasis>expectedBook.xml</emphasis> em XML Plano 
        provavelmente vai ficar parecido com o seguinte para fazer a 
        asserção passar:
      </para>
      <screen><![CDATA[
<?xml version="1.0" ?>
<dataset>
    <guestbook id="1" content="Hello buddy!" user="joe" />
    <guestbook id="2" content="I like it!" user="nancy" />
    <guestbook id="3" content="Hello world!" user="suzy" />
</dataset>
]]></screen>
      <para>
        Nós temos que consertar a chamada da Tabela Query:
      </para>
      <programlisting><![CDATA[<?php
$queryTable = $this->getConnection()->createQueryTable(
    'guestbook', 'SELECT id, content, user FROM guestbook'
);
?>]]></programlisting>
    </section>
    <section id="database.asserting-the-result-of-a-query">
      <title>Asseverando o Resultado de uma Query</title>
      <para>
        Você também pode asseverar o resultado de querys complexas com a abordagem 
        da Tabela Query, apenas especificando um nome de resultado com uma query e 
        comparando isso a um conjunto de dados:
      </para>
      <programlisting><![CDATA[<?php
class ComplexQueryTest extends PHPUnit_Extensions_Database_TestCase
{
    public function testComplexQuery()
    {
        $queryTable = $this->getConnection()->createQueryTable(
            'myComplexQuery', 'SELECT complexQuery...'
        );
        $expectedTable = $this->createFlatXmlDataSet("complexQueryAssertion.xml")
                              ->getTable("myComplexQuery");
        $this->assertTablesEqual($expectedTable, $queryTable);
    }
}
?>]]></programlisting>
    </section>
    <section id="database.asserting-the-state-of-multiple-tables">
      <title>Asseverando o Estado de Múltiplas Tabelas</title>
      <para>
        Certamente você pode asseverar o estado de múltiplas tabelas de uma vez e 
        comparar um conjunto de dados de query contra um conjunto de dados baseado em arquivo. Existem duas 
        formas diferentes de asserções de Conjuntos de Dados.
      </para>
      <orderedlist numeration="arabic">
        <listitem>
          <para>
            Você pode usar o Database (Banco de Dados - DB) e o DataSet (Conjunto de Dados) da Connection (Conexão) e 
            compará-lo com um Conjunto de Dados Baseado em Arquivo.
          </para>
          <programlisting><![CDATA[<?php
class DataSetAssertionsTest extends PHPUnit_Extensions_Database_TestCase
{
    public function testCreateDataSetAssertion()
    {
        $dataSet = $this->getConnection()->createDataSet(array('guestbook'));
        $expectedDataSet = $this->createFlatXmlDataSet('guestbook.xml');
        $this->assertDataSetsEqual($expectedDataSet, $dataSet);
    }
}
?>]]></programlisting>
        </listitem>
        <listitem>
          <para>
            Você pode construir o Conjunto de Dados por si próprio:
          </para>
          <programlisting><![CDATA[<?php
class DataSetAssertionsTest extends PHPUnit_Extensions_Database_TestCase
{
    public function testManualDataSetAssertion()
    {
        $dataSet = new PHPUnit_Extensions_Database_DataSet_QueryDataSet();
        $dataSet->addTable('guestbook', 'SELECT id, content, user FROM guestbook'); // additional tables
        $expectedDataSet = $this->createFlatXmlDataSet('guestbook.xml');

        $this->assertDataSetsEqual($expectedDataSet, $dataSet);
    }
}
?>]]></programlisting>
        </listitem>
      </orderedlist>
    </section>
  </section>
  <section id="database.frequently-asked-questions">
    <title>Perguntas Mais Frequentes</title>
    <section id="database.will-phpunit-re-create-the-database-schema-for-each-test">
      <title>O PHPUnit vai (re)criar o esquema do banco de dados para cada 
             teste?</title>
      <para>
        Não, o PHPUnit exige que todos os objetos do banco de dados estejam disponíveis quando a 
        suíte começar os testes. O Banco de Dados, tabelas, sequências, gatilhos e 
        visualizações devem ser criadas antes que você execute a suíte de testes.
      </para>
      <para>
        <ulink url="http://www.doctrine-project.org">Doctrine 2</ulink> ou
        <ulink url="http://www.ezcomponents.org">eZ Components</ulink> possuem 
        ferramentas poderosas que permitem a você criar o esquema de banco de dados através 
        de estruturas de dados pré-definidas, porém devem ser ligados à 
        extensão do PHPUnit para permitir a recriação automática de banco de dados 
        antes que a suíte de testes completa seja executada.
      </para>
      <para>
        Já que cada teste limpa completamente o banco de dados, você nem sequer é 
        forçado a recriar o banco de dados para cada execução de teste. Um banco de dados 
        permanentemente disponível funciona perfeitamente.
      </para>
    </section>
    <section id="database.am-i-required-to-use-pdo-in-my-application-for-the-database-extension-to-work">
      <title>Sou forçado a usar PDO em minha aplicação para que a Extensão para 
             Banco de Dados funcione?</title>
      <para>
        Não, PDO só é exigido para limpeza e configuração do ambiente e para 
        asserções. Você pode usar qualquer abstração de banco de dados que quiser 
        dentro de seu próprio código.
      </para>
    </section>
    <section id="database.what-can-i-do-when-i-get-a-too-much-connections-error">
      <title>O que posso fazer quando recebo um Erro
             <quote>Too much Connections</quote>?</title>
      <para>
        Se você não armazena em cache a instância de PDO que é criada a partir do 
        método do Caso de Teste <literal>getConnection()</literal> o número de 
        conexões ao banco de dados é aumentado em um ou mais com cada 
        teste do banco de dados. Com a configuração padrão o MySQL só permite 100 
        conexões concorrentes e outros fornecedores também têm um limite máximo 
        de conexões.
      </para>
      <para>
        A Sub-seção
        <quote>Use seu próprio Caso Abstrato de Teste de Banco de Dados</quote> mostra como 
        você pode prevenir o acontecimento desse erro usando uma instância única armazenada 
        em cache do PDO em todos os seus testes.
      </para>
    </section>
    <section id="database.how-to-handle-null-with-flat-xml-csv-datasets">
      <title>Como lidar com NULL usando Conjuntos de Dados XML Plano / CSV?</title>
      <para>
        Não faça isso. Em vez disso, você deveria usar Conjuntos de Dados ou 
        XML ou YAML.
      </para>
    </section>
  </section>
</chapter>

<?xml version="1.0" encoding="utf-8" ?>

<chapter id="code-coverage-analysis">
  <title>Code Coverage Analysis</title>

  <caution>
    <para>
      You are looking at the documentation for a version of PHPUnit that is no
      longer supported.
    </para>

    <para>
      The documentation for the current version of PHPUnit can be found
      <ulink url="../../current/en/index.html">here</ulink>.
    </para>
  </caution>

  <para>
    You have learned how to use unit tests to test your code. But how do you
    test your tests? How do you find code that is not yet tested -- or, in
    other words, not yet <emphasis>covered</emphasis> by a test? How do you
    measure testing completeness? All these questions are answered by a
    practice called Code Coverage Analysis. Code Coverage Analysis gives you
    an insight into what parts of the production code are executed when the
    tests are run.
  </para>

  <para>
    <indexterm><primary>Code Coverage</primary></indexterm>

    PHPUnit's Code Coverage Analysis utilizes the statement coverage
    functionality provided by the <ulink url="http://www.xdebug.org/">Xdebug</ulink>
    extension. An example of what statement coverage means is that if there is
    a method with 100 lines of code, and only 75 of these lines are actually
    executed when tests are being run, then the method is considered to have a
    code coverage of 75 percent.
  </para>

  <para>
    Let us generate a code coverage report for the <literal>BankAccount</literal>
    class from <xref linkend="test-driven-development.bankaccount-example.examples.BankAccount2.php" />.
  </para>

  <screen><userinput>phpunit --coverage-html ./report BankAccountTest</userinput>
PHPUnit 3.3.0 by Sebastian Bergmann.

...

Time: 0 seconds

OK (3 tests, 3 assertions)

Generating report, this may take a moment.</screen>

  <para>
    <xref linkend="code-coverage-analysis.figures.Code_Coverage.png" /> shows
    an excerpt from a Code Coverage report. Lines of code that were executed
    while running the tests are highlighted green, lines of code that are
    executable but were not executed are highlighted red, and "dead code" is
    highlighted orange. The number left to the actual line of code indicates
    how many tests cover that line.
  </para>

  <figure id="code-coverage-analysis.figures.Code_Coverage.png">
    <title>Code Coverage for setBalance()</title>

    <graphic fileref="figures/Code_Coverage.png" />
  </figure>

  <para>
    Clicking on the line number of a covered line will open a panel (see
    <xref linkend="code-coverage-analysis.figures.Code_Coverage2.png"/>) that
    shows the test cases that cover this line.
  </para>

  <figure id="code-coverage-analysis.figures.Code_Coverage2.png">
    <title>Panel with information on covering tests</title>

    <graphic fileref="figures/Code_Coverage2.png" />
  </figure>

  <para>
    The code coverage report for our <literal>BankAccount</literal> example
    shows that we do not have any tests yet that call the
    <literal>setBalance()</literal>, <literal>depositMoney()</literal>, and
    <literal>withdrawMoney()</literal> methods with legal values.
    <xref linkend="code-coverage-analysis.examples.BankAccountTest.php" />
    shows a test that can be added to the <literal>BankAccountTest</literal>
    test case class to completely cover the <literal>BankAccount</literal>
    class.
  </para>

  <example id="code-coverage-analysis.examples.BankAccountTest.php">
    <title>Test missing to achieve complete code coverage</title>
    <programlisting><![CDATA[<?php
require_once 'PHPUnit/Framework.php';
require_once 'BankAccount.php';

class BankAccountTest extends PHPUnit_Framework_TestCase
{
    // ...

    public function testDepositWithdrawMoney()
    {
        $this->assertEquals(0, $this->ba->getBalance());
        $this->ba->depositMoney(1);
        $this->assertEquals(1, $this->ba->getBalance());
        $this->ba->withdrawMoney(1);
        $this->assertEquals(0, $this->ba->getBalance());
    }
}
?>]]></programlisting>
  </example>

  <para>
    <xref linkend="code-coverage-analysis.figures.Code_Coverage3.png" /> shows
    the code coverage of the <literal>setBalance()</literal> method with the
    additional test.
  </para>

  <figure id="code-coverage-analysis.figures.Code_Coverage3.png">
    <title>Code Coverage for <literal>setBalance()</literal> with additional test</title>

    <graphic fileref="figures/Code_Coverage3.png" />
  </figure>

  <section id="code-coverage-analysis.specifying-covered-methods">
    <title>Specifying Covered Methods</title>

    <para>
      <indexterm><primary>Annotation</primary></indexterm>
      <indexterm><primary>@covers</primary></indexterm>

      The <literal>@covers</literal> annotation (see
      <xref linkend="code-coverage-analysis.specifying-covered-methods.tables.annotations"/>)
      can be used in the test code to specify which method(s) a test method
      wants to test. If provided, only the code coverage information for the
      specified method(s) will be considered.
      <xref linkend="code-coverage-analysis.specifying-covered-methods.examples.BankAccountTest.php"/>
      shows an example.
    </para>

    <example id="code-coverage-analysis.specifying-covered-methods.examples.BankAccountTest.php">
      <title>Tests that specify which method they want to cover</title>
      <programlisting><![CDATA[<?php
require_once 'PHPUnit/Framework.php';
require_once 'BankAccount.php';

class BankAccountTest extends PHPUnit_Framework_TestCase
{
    protected $ba;

    protected function setUp()
    {
        $this->ba = new BankAccount;
    }

    /**
     * @covers BankAccount::getBalance
     */
    public function testBalanceIsInitiallyZero()
    {
        $this->assertEquals(0, $this->ba->getBalance());
    }

    /**
     * @covers BankAccount::withdrawMoney
     */
    public function testBalanceCannotBecomeNegative()
    {
        try {
            $this->ba->withdrawMoney(1);
        }

        catch (BankAccountException $e) {
            $this->assertEquals(0, $this->ba->getBalance());

            return;
        }

        $this->fail();
    }

    /**
     * @covers BankAccount::depositMoney
     */
    public function testBalanceCannotBecomeNegative2()
    {
        try {
            $this->ba->depositMoney(-1);
        }

        catch (BankAccountException $e) {
            $this->assertEquals(0, $this->ba->getBalance());

            return;
        }

        $this->fail();
    }

    /**
     * @covers BankAccount::getBalance
     * @covers BankAccount::depositMoney
     * @covers BankAccount::withdrawMoney
     */

    public function testDepositWithdrawMoney()
    {
        $this->assertEquals(0, $this->ba->getBalance());
        $this->ba->depositMoney(1);
        $this->assertEquals(1, $this->ba->getBalance());
        $this->ba->withdrawMoney(1);
        $this->assertEquals(0, $this->ba->getBalance());
    }
}
?>]]></programlisting>
    </example>

    <table id="code-coverage-analysis.specifying-covered-methods.tables.annotations">
      <title>Supported annotations for specifying covered methods</title>

      <tgroup cols="2" align="left" colsep="1" rowsep="1">
        <thead>
          <row>
            <entry>Annotation</entry>
            <entry>Description</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry><literal><![CDATA[@covers ClassName::methodName]]></literal></entry>
            <entry><literal>Specifies that the annotated test method covers the specified method.</literal></entry>
          </row>
          <row>
            <entry><literal><![CDATA[@covers ClassName]]></literal></entry>
            <entry><literal>Specifies that the annotated test method covers all methods of a given class.</literal></entry>
          </row>
          <row>
            <entry><literal><![CDATA[@covers ClassName<extended>]]></literal></entry>
            <entry><literal>Specifies that the annotated test method covers all methods of a given class and its parent class(es) and interface(s).</literal></entry>
          </row>
          <row>
            <entry><literal><![CDATA[@covers ClassName::<public>]]></literal></entry>
            <entry><literal>Specifies that the annotated test method covers all public methods of a given class.</literal></entry>
          </row>
          <row>
            <entry><literal><![CDATA[@covers ClassName::<protected>]]></literal></entry>
            <entry><literal>Specifies that the annotated test method covers all protected methods of a given class.</literal></entry>
          </row>
          <row>
            <entry><literal><![CDATA[@covers ClassName::<private>]]></literal></entry>
            <entry><literal>Specifies that the annotated test method covers all private methods of a given class.</literal></entry>
          </row>
          <row>
            <entry><literal><![CDATA[@covers ClassName::<!public>]]></literal></entry>
            <entry><literal>Specifies that the annotated test method covers all methods of a given class that are not public.</literal></entry>
          </row>
          <row>
            <entry><literal><![CDATA[@covers ClassName::<!protected>]]></literal></entry>
            <entry><literal>Specifies that the annotated test method covers all methods of a given class that are not protected.</literal></entry>
          </row>
          <row>
            <entry><literal><![CDATA[@covers ClassName::<!private>]]></literal></entry>
            <entry><literal>Specifies that the annotated test method covers all methods of a given class that are not private.</literal></entry>
          </row>
        </tbody>
      </tgroup>
    </table>
  </section>

  <section id="code-coverage-analysis.ignoring-code-blocks">
    <title>Ignoring Code Blocks</title>

    <para>
      <indexterm><primary>Annotation</primary></indexterm>
      <indexterm><primary>@codeCoverageIgnoreStart</primary></indexterm>
      <indexterm><primary>@codeCoverageIgnoreEnd</primary></indexterm>

      Sometimes you have blocks of code that you cannot test and that you may
      want to ignore during code coverage analysis. PHPUnit lets you do this
      using the <literal>@codeCoverageIgnoreStart</literal> and
      <literal>@codeCoverageIgnoreEnd</literal> annotations as shown in
      <xref linkend="code-coverage-analysis.ignoring-code-blocks.examples.Sample.php"/>.
    </para>

    <example id="code-coverage-analysis.ignoring-code-blocks.examples.Sample.php">
      <title>Using the <literal>@codeCoverageIgnoreStart</literal> and <literal>@codeCoverageIgnoreEnd</literal> annotations</title>
        <programlisting><![CDATA[<?php
class Sample
{
    // ...

    public function doSomething()
    {
        if (0) {
            // @codeCoverageIgnoreStart
            $this->doSomethingElse();
            // @codeCoverageIgnoreEnd
        }
    }

    // ...
}
?>]]></programlisting>
    </example>

    <para>
      The lines of code between the <literal>@codeCoverageIgnoreStart</literal>
      and <literal>@codeCoverageIgnoreEnd</literal> annotations are counted as
      executed (if they are executable) and will not be highlighted.
    </para>
  </section>

  <section id="code-coverage-analysis.including-excluding-files">
    <title>Including and Excluding Files</title>

    <para>
      <indexterm><primary>Code Coverage</primary></indexterm>
      <indexterm><primary>Blacklist</primary></indexterm>
      <indexterm><primary>Whitelist</primary></indexterm>
      <indexterm><primary>PHPUnit_Util_Filter</primary></indexterm>

      By default, all sourcecode files that contain at least one line of code
      that has been executed (and only these files) are included in the report.
      You can configure the sourcecode files that are included in the report
      using the <literal>PHPUnit_Util_Filter</literal> API (see
      <xref linkend="code-coverage-analysis.including-excluding-files.tables.filter-api"/>).
    </para>

    <table id="code-coverage-analysis.including-excluding-files.tables.filter-api">
      <title>The <literal>PHPUnit_Util_Filter</literal> API</title>

      <tgroup cols="2" align="left" colsep="1" rowsep="1">
        <thead>
          <row>
            <entry>Method</entry>
            <entry>Meaning</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry><literal>void addDirectoryToFilter(string $directory)</literal></entry>
            <entry>Adds all files from a directory that are suffixed with <literal>.php</literal> to the blacklist (recursively).</entry>
          </row>
          <row>
            <entry><literal>void addDirectoryToFilter(string $directory, string $suffix)</literal></entry>
            <entry>Adds all files from a directory that are suffixed with <literal>$suffix</literal> to the blacklist (recursively).</entry>
          </row>
          <row>
            <entry><literal>void addFileToFilter(string $filename)</literal></entry>
            <entry>Adds a file to the blacklist.</entry>
          </row>
          <row>
            <entry><literal>void removeDirectoryFromFilter(string $directory)</literal></entry>
            <entry>Removes all files from a directory that are suffixed with <literal>.php</literal> from the blacklist (recursively).</entry>
          </row>
          <row>
            <entry><literal>void removeDirectoryFromFilter(string $directory, string $suffix)</literal></entry>
            <entry>Removes all files from a directory that are suffixed with <literal>$suffix</literal> from the blacklist (recursively).</entry>
          </row>
          <row>
            <entry><literal>void removeFileFromFilter(string $filename)</literal></entry>
            <entry>Removes a file from the blacklist.</entry>
          </row>
          <row>
            <entry><literal>void addDirectoryToWhitelist(string $directory)</literal></entry>
            <entry>Adds all files from a directory that are suffixed with <literal>.php</literal> to the whitelist (recursively).</entry>
          </row>
          <row>
            <entry><literal>void addDirectoryToWhitelist(string $directory, string $suffix)</literal></entry>
            <entry>Adds all files from a directory that are suffixed with <literal>$suffix</literal> to the whitelist (recursively).</entry>
          </row>
          <row>
            <entry><literal>void addFileToWhitelist(string $filename)</literal></entry>
            <entry>Adds a file to the whitelist.</entry>
          </row>
          <row>
            <entry><literal>void removeDirectoryFromWhitelist(string $directory)</literal></entry>
            <entry>Removes all files from a directory that are suffixed with <literal>.php</literal> from the whitelist (recursively).</entry>
          </row>
          <row>
            <entry><literal>void removeDirectoryFromWhitelist(string $directory, string $suffix)</literal></entry>
            <entry>Removes all files from a directory that are suffixed with <literal>$suffix</literal> from the whitelist (recursively).</entry>
          </row>
          <row>
            <entry><literal>void removeFileFromWhitelist(string $filename)</literal></entry>
            <entry>Removes a file from the whitelist.</entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para>
      The blacklist is pre-filled with all sourcecode files of PHPUnit itself
      and the tests. When the whitelist is empty (default), blacklisting is used.
      When the whitelist is not empty, whitelisting is used. When whitelisting
      is used, each file on the whitelist is added to the code coverage report
      regardless of whether or not it was executed.
    </para>
  </section>
</chapter>

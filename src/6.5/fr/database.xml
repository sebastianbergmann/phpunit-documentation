<?xml version="1.0" encoding="utf-8" ?>

<chapter id="database">
  <title>Tester des bases de données</title>
  <para>
    De nombreux exemples de tests unitaires de niveau débutant ou intermédiaire
    dans de nombreux langages de programmation suggèrent qu'il est parfaitement facile de tester la logique de votre application avec
    de simples tests. Pour les applications centrées sur une base de données, c'est loin d'être la
    réalité. Commencez à utiliser WordPress, TYPO3 ou Symfony avec Doctrine ou Propel, par
    exemple, et nous serez vite confrontés à des problèmes considérables avec PHPUnit :
    juste parce que la base de données est vraiment étroitement liée à ces bibliothèques.
  </para>
  <note>
    <para>
      Assurez-vous d'avoir l'extension PHP <literal>pdo</literal> et les extensions
      spécifique à la base de données tel que <literal>pdo_mysql</literal> installées.
      Sinon, les exemples ci-dessous ne fonctionneront pas.
    </para>
  </note>
  <para>
    Vous connaissez probablement ce scénario rencontré tous les jours sur les projets,
    dans lequel vous voulez mettre à l'oeuvre votre savoir-faire tout neuf ou déjà aguerri en
    PHPUnit et où vous vous retrouvez bloqué par l'un des problèmes suivants :
  </para>
  <orderedlist numeration="arabic">
    <listitem>
      <para>
        La méthode que vous voulez tester exécute une opération JOIN plutôt
        vaste et utilise les données pour calculer certains résultats importants.
      </para>
    </listitem>
    <listitem>
      <para>
        Votre logique métier exécute un mélange d'instructions SELECT, INSERT, UPDATE et
        DELETE.
      </para>
    </listitem>
    <listitem>
      <para>
        Vous devez configurer les données de test dans (éventuellement beaucoup) plus
        de deux tables pour obtenir des données initiales raisonnables pour les méthodes que vous voulez tester.
      </para>
    </listitem>
  </orderedlist>
  <para>
    L'extension DbUnit simplifie considérablement la configuration d'une base de données à des fins
    de test et vous permet de vérifier le contenu d'une base de données après avoir
    réalisé une suite d'opérations.
  </para>
  <section id="database.supported-vendors-for-database-testing">
    <title>Systèmes gérés pour tester des bases de données</title>
    <para>
      DbUnit gère actuellement MySQL, PostgreSQL, Oracle et SQLite. Via
      l'intégration de <ulink url="http://framework.zend.com">Zend Framework</ulink> ou de
      <ulink url="http://www.doctrine-project.org">Doctrine 2</ulink>
      il est possible d'accéder à d'autres systèmes de base de données comme IBM DB2 ou
      Microsoft SQL Server.
    </para>
  </section>
  <section id="database.difficulties-in-database-testing">
    <title>Difficultés pour tester les bases de données</title>
    <para>
      Il y a une bonne raison pour laquelle les exemples concernant le test unitaire
      n'inclut pas d'interaction avec une base de données : ces types de test sont à la
      fois complexes à configurer et à maintenir. Quand vous faites des tests sur votre
      base de données, vous devez prendre soin des variables suivantes :
    </para>
    <itemizedlist>
      <listitem>
        <para>
          Le schéma et les tables de la base de données
        </para>
      </listitem>
      <listitem>
        <para>
          Insérer les lignes nécessaires pour le test dans ces tables
        </para>
      </listitem>
      <listitem>
        <para>
          Vérifier l'état de la base de données après que votre test a été exécuté
        </para>
      </listitem>
      <listitem>
        <para>
          Nettoyer la base de données pour chaque nouveau test
        </para>
      </listitem>
    </itemizedlist>
    <para>
      Comme de nombreuses APIs de base de données comme PDO, MySQLi ou OCI8 sont
      lourdes à utiliser et verbeuses à écrire, réaliser ces étapes à la main
      est un cauchemar absolu.
    </para>
    <para>
      Le code de test doit être aussi court et précis que possible pour plusieurs raisons :
    </para>
    <itemizedlist>
      <listitem>
        <para>
          Vous ne voulez pas modifier un volume considérable de code de test pour
          de petites modifications dans votre code de production.
        </para>
      </listitem>
      <listitem>
        <para>
          Vous voulez être capable de lire et de comprendre le code de test
          facilement, même des mois après l'avoir écrit.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      De plus, vous devez prendre conscience que la base de données est essentiellement
      une variable globale pour votre code. Deux tests de votre série de tests
      peuvent être exécutés sur la même base de données, potentiellement en réutilisant les données
      plusieurs fois. Un échec dans un test peut facilement affecter le résultat des tests suivants
      rendant votre expérimentation de test très difficile. L'étape de nettoyage mentionnée précédemment
      est d'une importance majeure pour résoudre le problème posé par le fait que
      <quote>la base de données est une variable globale</quote>.
    </para>
    <para>
      DbUnit aide à simplifier tous ces problèmes avec le test de base de données
      d'une manière élégante.
    </para>
    <para>
      Là où PHPUnit ne peut pas vous aider c'est pour le fait que les tests
      de base de données sont très lents comparés aux tests n'en utilisant pas. Selon
      l'importance des interactions avec votre base de données, vos tests
      peuvent s'exécuter sur une durée considérable. Cependant, si vous gardez petit le volume de
      données utilisées pour chaque test et que vous essayez de tester le plus de code possible en utilisant
      des tests qui ne font pas appel à une base de données, vous pouvez facilement rester très en dessous
      d'une minute, même pour de grandes séries de tests.
    </para>
    <para>
      La suite de test du <ulink url="http://www.doctrine-project.org">projet Doctrine 2
      </ulink>, par exemple, possède actuellement une suite de tests d'environ 1000 tests
      dont presque la moitié accède à la base de données et continue à s'exécuter en 15
      secondes sur une base de données MySQL sur un ordinateur de
      bureau standard.
    </para>
  </section>
  <section id="database.the-four-stages-of-a-database-test">
    <title>Les quatre phases d'un test de base de données</title>
    <para>
      Dans son livre sur les patterns de tests xUnit, Gerard Meszaros liste les
      quatre phases d'un test unitaire :
    </para>
    <orderedlist numeration="arabic">
      <listitem>
        <para>
          Configurer une fixture
        </para>
      </listitem>
      <listitem>
        <para>
          Expérimenter le système à tester
        </para>
      </listitem>
      <listitem>
        <para>
          Vérifier les résultats
        </para>
      </listitem>
      <listitem>
        <para>
          Nettoyer
        </para>
      </listitem>
    </orderedlist>
    <blockquote>
      <para>
        <emphasis role="strong">Qu'est-ce qu'une fixture ?</emphasis>
      </para>
      <para>
        Une fixture décrit l'état initial dans lequel se trouvent votre application
        et votre base de données quand vous exécutez un test.
      </para>
    </blockquote>
    <para>
      Tester la base de données nécessite au moins d'intervenir dans
      setup et teardown pour nettoyer et écrire les données de fixture
      nécessaires dans vos tables. Cependant, l'extension de base de données possède une bonne raison
      de rétablir les quatre phases dans un test de base de données pour constituer le processus suivant
      qui est exécuté pour chacun des tests :
    </para>
    <section id="database.clean-up-database">
      <title>1. Nettoyer la base de données</title>
      <para>
        Puisqu'il y a toujours un premier test qui s'exécute en faisant
        appel à la base de données, vous n'êtes pas sûr qu'il y ait déjà
        des données dans les tables. PHPUnit va exécuter un TRUNCATE sur toutes
        les tables que vous avez indiquées pour les remettre à l'état vide.
      </para>
    </section>
    <section id="database.set-up-fixture">
      <title>2. Configurer les fixtures</title>
      <para>
        PHPUnit va parcourir toutes les lignes de fixture indiquées et les
        insérer dans leurs tables respectives.
      </para>
    </section>
    <section id="database.run-test-verify-outcome-and-teardown">
      <title>3–5. Exécuter les tests, vérifier les résultats et nettoyer</title>
      <para>
        Une fois la base de données réinitialisée et remise dans son état de départ,
        le test en tant que tel est exécuté par PHPUnit. Cette partie du code de test
        ne nécessite pas du tout de s'occuper de l'extension base de données,
        vous pouvez procéder et tester tout ce que vous voulez dans votre code.
      </para>
      <para>
        Votre test peut utiliser une assertion spéciale appelée
        <literal>assertDataSetsEqual()</literal> à des fins de vérification,
        mais c'est totalement facultatif. Cette fonctionnalité sera expliquée
        dans la section <quote>Assertions pour les bases de données</quote>.
      </para>
    </section>
  </section>
  <section id="database.configuration-of-a-phpunit-database-testcase">
    <title>Configuration d'un cas de test de base de données PHPUnit</title>
    <para>
      Habituellement quand vous utilisez PHPUnit, vos cas de tests devraient
      hériter de la classe
      <literal>PHPUnit\Framework\TestCase</literal> de la façon suivante :
    </para>
    <programlisting><![CDATA[<?php
use PHPUnit\Framework\TestCase;

class MyTest extends TestCase
{
    public function testCalculate()
    {
        $this->assertEquals(2, 1 + 1);
    }
}
?>]]></programlisting>
    <para>
      Si vous voulez tester du code qui fonctionne avec l'extension base de données,
      le setup sera un peu plus complexe et vous devrez hériter d'un cas de test
      abstrait différent qui nécessite que vous implémentiez deux méthodes abstraites
      <literal>getConnection()</literal> et
      <literal>getDataSet()</literal>:
    </para>
    <programlisting><![CDATA[<?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class MyGuestbookTest extends TestCase
{
    use TestCaseTrait;

    /**
     * @return PHPUnit_Extensions_Database_DB_IDatabaseConnection
     */
    public function getConnection()
    {
        $pdo = new PDO('sqlite::memory:');
        return $this->createDefaultDBConnection($pdo, ':memory:');
    }

    /**
     * @return PHPUnit_Extensions_Database_DataSet_IDataSet
     */
    public function getDataSet()
    {
        return $this->createFlatXMLDataSet(dirname(__FILE__).'/_files/guestbook-seed.xml');
    }
}
?>]]></programlisting>
    <section id="database.implementing-getconnection">
      <title>Implémenter getConnection()</title>
      <para>
        Pour permettre aux fonctionnalités de nettoyage et de chargement des fixtures de fonctionner,
        l'extension de base de données PHPUnit nécessite d'accéder à une connexion de base de données
        abstraite pour les différents fournisseurs via la bibliothèque PDO. Il est important de noter
        que votre application n'a pas besoin de s'appuyer sur PDO pour utiliser
        l'extension de base de données de PHPUnit, la connexion est
        principalement utilisée pour le nettoyage et la configuration de setup.
      </para>
      <para>
        Dans l'exemple précédent, nous avons créé une connexion Sqlite en mémoire
        et nous l'avons passé à la méthode <literal>createDefaultDBConnection</literal>
        qui encapsule l'instance PDO et le second paramètre (le
        nom de la base de données) dans une couche d'abstraction très simple pour connexion
        aux bases de données du type
        <literal>PHPUnit_Extensions_Database_DB_IDatabaseConnection</literal>.
      </para>
      <para>
        La section <quote>Utiliser la connexion de base de données</quote> explicite l'API
        de cette interface et comment en faire le meilleur usage.
      </para>
    </section>
    <section id="database.implementing-getdataset">
      <title>Implémenter getDataSet()</title>
      <para>
        La méthode <literal>getDataSet()</literal> définit à quoi doit ressembler
        l'état initial de la base de données avant que chaque test ne soit
        exécuté. L'état de la base de données est abstrait par les
        concepts DataSet et DataTable, tous les deux représentés par les
        interfaces
        <literal>PHPUnit_Extensions_Database_DataSet_IDataSet</literal> et
        <literal>PHPUnit_Extensions_Database_DataSet_IDataTable</literal>.
        La prochaine section décrira en détail comment ces concepts fonctionnent
        et quels sont les avantages à les utiliser lors des tests de base de données.
      </para>
      <para>
        Pour l'implémentation, nous avons seulement besoin de savoir que la méthode
        <literal>getDataSet()</literal> est appelée une fois dans
        <literal>setUp()</literal> pour récupérer l'ensemble de données de la fixture
        et l'insérer dans la base de données. Dans l'exemple, nous utilisons une méthode
        fabrique <literal>createFlatXMLDataSet($filename)</literal> qui
        représente un ensemble de données à l'aide d'une représentation XML.
      </para>
    </section>
    <section id="database.what-about-the-database-schema-ddl">
      <title>Qu'en est-il du schéma de base de données (DDL)?</title>
      <para>
        PHPUnit suppose que le schéma de base de données avec toutes ses tables,
        ses triggers, séquences et vues est créé avant qu'un test soit exécuté.
        Cela signifie que vous, en tant que développeur, devez vous assurer que la base
        de données est correctement configurée avant de lancer la suite de tests.
      </para>
      <para>
        Il y a plusieurs moyens pour satisfaire cette condition préalable
        au test de base de données.
      </para>
      <orderedlist numeration="arabic">
        <listitem>
          <para>
            Si vous utilisez une base de données persistante (pas Sqlite en mémoire) vous pouvez
            facilement configure la base de données avec des outils tels que phpMyAdmin pour
            MySQL et réutiliser la base de données pour chaque exécution de test.
          </para>
        </listitem>
        <listitem>
          <para>
            Si vous utilisez des bibliothèques comme
            <ulink url="http://www.doctrine-project.org">Doctrine 2</ulink> ou
            <ulink url="http://www.propelorm.org/">Propel</ulink>
            vous pouvez utiliser leurs APIs pour créer le schéma de base de données dont
            vous avez besoin une fois avant de lancer vos tests. Vous pouvez utiliser les possibilités apportées par
            <ulink url="http://www.phpunit.de/manual/current/en/textui.html">l'amorce et la configuration de PHPUnit</ulink>
            pour exécuter ce code à chaque fois que vos tests sont exécutés.
          </para>
        </listitem>
      </orderedlist>
    </section>
    <section id="database.tip-use-your-own-abstract-database-testcase">
      <title>Astuce: utilisez votre propre cas de tests abstrait de base de données</title>
      <para>
        En partant des exemples d'implémentation précédents, vous pouvez facilement voir que la méthode
        <literal>getConnection()</literal> est plutôt statique et peut être
        réutilisée dans différents cas de test de base de données. Additionnellement
        pour conserver de bonnes performances pour vos tests et maintenir la charge de la
        base de données basse vous pouvez refactoriser un peu le code pour obtenir
        un cas de test abstrait générique pour votre application, qui vous permette encore
        d'indiquer des données de fixture différentes pour chaque cas de test :
      </para>
      <programlisting><![CDATA[<?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

abstract class MyApp_Tests_DatabaseTestCase extends TestCase
{
    use TestCaseTrait;

    // only instantiate pdo once for test clean-up/fixture load
    static private $pdo = null;

    // only instantiate PHPUnit_Extensions_Database_DB_IDatabaseConnection once per test
    private $conn = null;

    final public function getConnection()
    {
        if ($this->conn === null) {
            if (self::$pdo == null) {
                self::$pdo = new PDO('sqlite::memory:');
            }
            $this->conn = $this->createDefaultDBConnection(self::$pdo, ':memory:');
        }

        return $this->conn;
    }
}
?>]]></programlisting>
      <para>
        Mais la connexion à la base de données reste codée en dur dans la
        connexion PDO. PHPUnit possède une autre fonctionnalité formidable
        qui peut rendre ce cas de test encore plus générique. Si vous utilisez
        <ulink url="appendixes.configuration.html#appendixes.configuration.php-ini-constants-variables"> la configuration XML</ulink>,
        vous pouvez rendre la connexion à la base de données configurable pour chaque exécution de test.
        Créons d'abord un fichier <quote>phpunit.xml</quote> dans le répertoire tests/
        de l'application qui ressemble à ceci :
      </para>
      <screen><![CDATA[
<?xml version="1.0" encoding="UTF-8" ?>
<phpunit>
    <php>
        <var name="DB_DSN" value="mysql:dbname=myguestbook;host=localhost" />
        <var name="DB_USER" value="user" />
        <var name="DB_PASSWD" value="passwd" />
        <var name="DB_DBNAME" value="myguestbook" />
    </php>
</phpunit>
]]></screen>
      <para>
        Nous pouvons maintenant modifier notre cas de test pour qu'il ressemble à ça :
      </para>
      <programlisting><![CDATA[<?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

abstract class Generic_Tests_DatabaseTestCase extends TestCase
{
    use TestCaseTrait;

    // only instantiate pdo once for test clean-up/fixture load
    static private $pdo = null;

    // only instantiate PHPUnit_Extensions_Database_DB_IDatabaseConnection once per test
    private $conn = null;

    final public function getConnection()
    {
        if ($this->conn === null) {
            if (self::$pdo == null) {
                self::$pdo = new PDO( $GLOBALS['DB_DSN'], $GLOBALS['DB_USER'], $GLOBALS['DB_PASSWD'] );
            }
            $this->conn = $this->createDefaultDBConnection(self::$pdo, $GLOBALS['DB_DBNAME']);
        }

        return $this->conn;
    }
}
?>]]></programlisting>
      <para>
        Nous pouvons maintenant lancer la suite de tests de la base de données en utilisant différentes
        configurations depuis l'interface en ligne de commandes:
      </para>
      <screen><userinput>user@desktop> phpunit --configuration developer-a.xml MyTests/</userinput>
<userinput>user@desktop> phpunit --configuration developer-b.xml MyTests/</userinput></screen>
      <para>
        La possibilité de lancer facilement des tests de base de données sur différentes
        bases de données cibles est très important si vous développez sur une machine
        de développement. Si plusieurs développeurs exécutent les tests de base de données
        sur la même connexion de base de données, vous pouvez facilement faire l'expérience
        d'échec de tests du fait des concurrences d'accès.
      </para>
    </section>
  </section>
  <section id="database.understanding-datasets-and-datatables">
    <title>Comprendre DataSets et DataTables</title>
    <para>
      Un concept centre de l'extension de base de données PHPUnit sont les
      DataSets et les DataTables. Vous devez comprendre ce simple concept
      pour maîtriser les tests de bases de données avec PHPUnit. Les DataSets
      et les DataTables constituent une couche d'abstraction sur les tables,
      les lignes et les colonnes de la base de données. Une simple API cache le contenu
      de la base de données sous-jacente dans une structure objet, qui peut également
      être implémentée par d'autres sources qui ne sont pas des bases de données.
    </para>
    <para>
      Cette abstraction est nécessaire pour comparer le contenu constaté
      d'une base de données avec le contenu attendu. Les attentes peuvent
      être représentées dans des fichiers XML, YAML ou CSV ou des tableaux PHP
      par exemple. Les interfaces DataSets et DataTables permettent de comparer
      ces sources conceptuellement différentes en émulant un stockage en base
      de données relationnelle dans une approche sémantiquement similaire.
    </para>
    <para>
      Un processus pour des assertions de base de données dans vos tests
      se limitera alors à trois étapes simples :
    </para>
    <itemizedlist>
      <listitem>
        <para>
          Indiquer une ou plusieurs tables dans votre base de données via leurs
          noms de table (ensemble de données constatées)
        </para>
      </listitem>
      <listitem>
        <para>
          Indiquez l'ensemble de données attendu dans votre format préféré (YAML, XML,
          ..)
        </para>
      </listitem>
      <listitem>
        <para>
          Affirmez que les représentations des deux ensembles de données sont égaux.
        </para>
      </listitem>
    </itemizedlist>
    <para>
      Les assertions ne constituent pas le seul cas d'utilisation des DataSets
      et DataTables dans l'extension de base de données PHPUnit. Comme illustré
      dans la section précédente, ils décrivent également le contenu initial de la
      base de données. Vous êtes obligés de définir un ensemble de données fixture
      avec le cas de test Database, qui est ensuite utilisé pour :
    </para>
    <itemizedlist>
      <listitem>
        <para>
          Supprimer toutes les lignes des tables indiquées dans le DataSet.
        </para>
      </listitem>
      <listitem>
        <para>
          Ecrire toutes les lignes dans les tables de données dans la base de données.
        </para>
      </listitem>
    </itemizedlist>
    <section id="database.available-implementations">
      <title>Implémentations disponibles</title>
      <para>
        Il existe trois types différents de datasets/datatables:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            DataSets et DataTables basés sur des fichiers
          </para>
        </listitem>
        <listitem>
          <para>
            DataSets et DataTables basés sur des requêtes
          </para>
        </listitem>
        <listitem>
          <para>
            DataSets et DataTables de filtre et de combinaison
          </para>
        </listitem>
      </itemizedlist>
      <para>
        les datasets et les tables basés sur des fichiers sont généralement
        utilisés pour la fixture initiale et pour décrire l'état attendu d'une base de données.
      </para>
      <section id="database.flat-xml-dataset">
        <title>DataSet en XML à plat</title>
        <para>
          Le dataset le plus commun est appelé XML à plat (flat XML). C'est un format
          xml très simple dans lequel une balise à l'intérieur d'un noeud racine
          <literal><![CDATA[<dataset>]]></literal> représente exactement une ligne de la base
          de données. Les noms des balises sont ceux des tables dans lesquelles insérer les
          lignes et un attribut représente la colonne. Un exemple pour une simple application
          de livre d'or pourrait ressembler à ceci :
        </para>
        <screen><![CDATA[
<?xml version="1.0" ?>
<dataset>
    <guestbook id="1" content="Hello buddy!" user="joe" created="2010-04-24 17:15:23" />
    <guestbook id="2" content="I like it!" user="nancy" created="2010-04-26 12:14:20" />
</dataset>
]]></screen>
        <para>
          C'est à l'évidence facile à écrire. Ici,
          <literal><![CDATA[<guestbook>]]></literal> est le nom de la table dans laquelle les deux
          lignes sont insérées, chacune avec quatre colonnes <quote>id</quote>,
          <quote>content</quote>, <quote>user</quote> et
          <quote>created</quote> et leurs valeurs respectives.
        </para>
        <para>
          Cependant, cette simplicité a un coût.
        </para>
        <para>
          Avec l'exemple précédent, difficile de voir comment nous devons indiquer
          une table vide. Vous pouvez insérer une balise avec aucun attribut
          contenant le nom de la table vide. Un fichier XML à plat pour une table
          livre_d_or pourrait alors ressembler à ceci:
        </para>
        <screen><![CDATA[
<?xml version="1.0" ?>
<dataset>
    <guestbook />
</dataset>
]]></screen>
        <para>
          La gestion des valeurs NULL avec le dataset en XML à plat est fastidieuse.
          Une valeur NULL est différente d'une chaîne vide dans la plupart des bases
          de données (Oracle étant une exception), quelque chose qu'il est difficile
          de décrire dans le format XML à plat. Vous pouvez représenter une valeur NULL
          en omettant d'attribut indiquant la ligne. Si votre livre d'or autorise les entrées
          anonymes représentées par une valeur NULL dans la colonne utilisateur, un état
          hypothétique de la table guestbook pourrait ressembler à ceci:
        </para>
        <screen><![CDATA[
<?xml version="1.0" ?>
<dataset>
    <guestbook id="1" content="Hello buddy!" user="joe" created="2010-04-24 17:15:23" />
    <guestbook id="2" content="I like it!" created="2010-04-26 12:14:20" />
</dataset>
]]></screen>
        <para>
          Dans ce cas, la seconde entrée est postée anonymement. Cependant,
          ceci conduit à un sérieux problème pour la reconnaissance de la colonne.
          Lors des assertions d'égalité de datasets, chaque dataset doit indiquer
          quelle colonne une table contient. Si un attribut est NULL pour toutes les
          lignes de la data-table, comment l'extension de base de données sait que la colonne
          doit faire partie de la table ?
        </para>
        <para>
          Le dataset en XML à plat fait maintenant une hypothèse cruciale en
          décrétant que les attributs de la première ligne définie pour une table
          définissent les colonnes de cette table. Dans l'exemple précédent, ceci signifierait que
          <quote>id</quote>, <quote>content</quote>, <quote>user</quote> et
          <quote>created</quote> sont les colonnes de la table guestbook. Pour la
          seconde ligne dans laquelle <quote>user</quote> n'est pas défini, un NULL
          sera inséré dans la base de données.
        </para>
        <para>
          Quand la première entrée du livre d'or est supprimée du dataset,
          seuls <quote>id</quote>, <quote>content</quote> et
          <quote>created</quote> seront des colonnes de la table guestbook,
          puisque <quote>user</quote> n'est pas indiqué.
        </para>
        <para>
          Pour utiliser efficacement le dataset au format XML à plat quand des valeurs
          NULL sont pertinentes, la première ligne de chaque table ne doit contenir aucune
          valeur NULL, seules les lignes suivantes pouvant omettre des attributs.
          Ceci peut s'avérer délicat, puisque l'ordre des lignes est un élément
          pertinent pour les assertions de base de données.
        </para>
        <para>
          A l'inverse, si vous n'indiquez qu'un sous-élément des colonnes de la table
          dans le dataset au format XML à plat, toutes les valeurs omises sont positionnées
          à leurs valeurs par défaut. Ceci provoquera des erreurs si l'une des valeurs omises
          est définie par <quote>NOT NULL DEFAULT NULL</quote>.
        </para>
        <para>
          En conclusion, je ne peux que vous conseiller de n'utiliser les datasets
          au format XML à plat que si vous n'avez pas besoin des valeurs NULL.
        </para>
        <para>
          Vous pouvez créer une instance de dataset au format XML à plat
          dans votre cas de test de base de données en appelant la méthode
          <literal>createFlatXmlDataSet($filename)</literal>:
        </para>
        <programlisting><![CDATA[<?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class MyTestCase extends TestCase
{
    use TestCaseTrait;

    public function getDataSet()
    {
        return $this->createFlatXmlDataSet('myFlatXmlFixture.xml');
    }
}
?>]]></programlisting>
      </section>
      <section id="database.xml-dataset">
        <title>DataSet XML</title>
        <para>
          Il existe un autre dataset XML davantage structuré, qui est un peu plus
          verbeux à écrire mais qui évite les problèmes de NULL du dataset au
	        format XML à plat. Dans le noeud racine <literal><![CDATA[<dataset>]]></literal> vous
          pouvez indiquer les balises <literal><![CDATA[<table>]]></literal>,
          <literal><![CDATA[<column>]]></literal>, <literal><![CDATA[<row>]]></literal>,
          <literal><![CDATA[<value>]]></literal> et
          <literal><![CDATA[<null />]]></literal>. Un dataset équivalent à celui
          défini précédemment pour le livre d'or en format XML à plat ressemble à :
        </para>
        <screen><![CDATA[
<?xml version="1.0" ?>
<dataset>
    <table name="guestbook">
        <column>id</column>
        <column>content</column>
        <column>user</column>
        <column>created</column>
        <row>
            <value>1</value>
            <value>Hello buddy!</value>
            <value>joe</value>
            <value>2010-04-24 17:15:23</value>
        </row>
        <row>
            <value>2</value>
            <value>I like it!</value>
            <null />
            <value>2010-04-26 12:14:20</value>
        </row>
    </table>
</dataset>
]]></screen>
        <para>
          Tout <literal><![CDATA[<table>]]></literal> défini possède un nom et nécessite
          la définition de toutes les colonnes avec leurs noms. Il peut contenir zéro ou tout
          nombre positif d'éléments <literal><![CDATA[<row>]]></literal> imbriqués.
          Ne définir aucun élément <literal><![CDATA[<row>]]></literal> signifie que la table est vide.
          Les balises <literal><![CDATA[<value>]]></literal> et
          <literal><![CDATA[<null />]]></literal> doivent être indiquées dans l'ordre des éléments
          <literal><![CDATA[<column>]]></literal>précédemment donnés.
          La balise <literal><![CDATA[<null />]]></literal> signifie évidemment que la
          valeur est NULL.
        </para>
        <para>
          Vous pouvez créer une instance de dataset xml dans votre
          cas de test de base de données en appelant la méthode
          <literal>createXmlDataSet($filename)</literal> :
        </para>
        <programlisting><![CDATA[<?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class MyTestCase extends TestCase
{
    use TestCaseTrait;

    public function getDataSet()
    {
        return $this->createXMLDataSet('myXmlFixture.xml');
    }
}
?>]]></programlisting>
      </section>
      <section id="database.mysql-xml-dataset">
        <title>DataSet XML MySQL</title>
        <para>
          Ce nouveau format XML est spécifique au
          <ulink url="http://www.mysql.com">serveur de bases de données MySQL</ulink>.
          Sa gestion a été ajoutée dans PHPUnit 3.5. Les fichiers écrits ce format peuvent
          être générés avec l'utilitaire
          <ulink url="http://dev.mysql.com/doc/refman/5.0/en/mysqldump.html"><literal>mysqldump</literal></ulink>.
          Contrairement aux datasets CSV, que <literal>mysqldump</literal>
          gère également, un unique fichier de ce format XML peut contenir des données
          pour de multiples tables. Vous pouvez créer un fichier dans ce format en
          invoquant <literal>mysqldump</literal> de cette façon :
        </para>
        <screen><userinput>mysqldump --xml -t -u [username] --password=[password] [database] > /path/to/file.xml</userinput></screen>
        <para>
          Ce fichier peut être utilisé dans votre case de test de base de données en appelant
          la méthode <literal>createMySQLXMLDataSet($filename)</literal>:
        </para>
        <programlisting><![CDATA[<?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class MyTestCase extends TestCase
{
    use TestCaseTrait;

    public function getDataSet()
    {
        return $this->createMySQLXMLDataSet('/path/to/file.xml');
    }
}
?>]]></programlisting>
      </section>
      <section id="database.yaml-dataset">
        <title>DataSet YAML</title>
        <para>
          Alternativement, vous pouvez utiliser un dataset YAML pour l'exemple du livre d'or:
        </para>
        <screen><![CDATA[
guestbook:
  -
    id: 1
    content: "Hello buddy!"
    user: "joe"
    created: 2010-04-24 17:15:23
  -
    id: 2
    content: "I like it!"
    user:
    created: 2010-04-26 12:14:20
]]></screen>
        <para>
          C'est simple, pratique ET ça règle le problème de NULL que pose le dataset
          équivalent au format XML à plat. Un NULL en YAML s'exprime simplement
          en donnant le nom de la colonne sans indiquer de valeur. Une chaîne vide est indiquée par
          <literal><![CDATA[column1: ""]]></literal>.
        </para>
        <para>
          Le dataset YAML ne possède pas actuellement de méthode de fabrique
          pour le cas de tests de base de données, si bien que vous devez l'instancier manuellement :
        </para>
        <programlisting><![CDATA[<?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;
use PHPUnit\DbUnit\DataSet\YamlDataSet;

class YamlGuestbookTest extends TestCase
{
    use TestCaseTrait;

    protected function getDataSet()
    {
        return new YamlDataSet(dirname(__FILE__)."/_files/guestbook.yml");
    }
}
?>]]></programlisting>
      </section>
      <section id="database.csv-dataset">
        <title>DataSet CSV</title>
        <para>
          Un autre dataset au format fichier est basé sur les fichiers CSV. Chaque table
          du dataset est représenté par un fichier CSV. Pour notre exemple de livre d'or,
          nous pourrions définir un fichier guestbook-table.csv:
        </para>
        <screen><![CDATA[
id,content,user,created
1,"Hello buddy!","joe","2010-04-24 17:15:23"
2,"I like it!","nancy","2010-04-26 12:14:20"
]]></screen>
        <para>
          Bien que ce soit très pratique à éditer avec Excel ou OpenOffice,
          vous ne pouvez pas indiquer de valeurs NULL avec le dataset CSV. Une
          colonne vide conduira à ce que la valeur vide par défaut de la base de
          données soit insérée dans la colonne.
        </para>
        <para>
          Vous pouvez créer un dataset CSV en appelant :
        </para>
        <programlisting><![CDATA[<?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;
use PHPUnit\DbUnit\DataSet\CsvDataSet;

class CsvGuestbookTest extends TestCase
{
    use TestCaseTrait;

    protected function getDataSet()
    {
        $dataSet = new CsvDataSet();
        $dataSet->addTable('guestbook', dirname(__FILE__)."/_files/guestbook.csv");
        return $dataSet;
    }
}
?>]]></programlisting>
      </section>
      <section id="database.array-dataset">
        <title>DataSet tableau</title>
        <para>
          Il n'existe pas (encore) de DataSet basé sur les tableaux dans
          l'extension base de données de PHPUnit, mais vous pouvez implémenter
          facilement la vôtre. Notre exemple du Livre d'or devrait ressembler à :
        </para>
        <programlisting><![CDATA[<?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class ArrayGuestbookTest extends TestCase
{
    use TestCaseTrait;

    protected function getDataSet()
    {
        return new MyApp_DbUnit_ArrayDataSet(
            [
                'guestbook' => [
                    [
                        'id' => 1,
                        'content' => 'Hello buddy!',
                        'user' => 'joe',
                        'created' => '2010-04-24 17:15:23'
                    ],
                    [
                        'id' => 2,
                        'content' => 'I like it!',
                        'user' => null,
                        'created' => '2010-04-26 12:14:20'
                    ],
                ],
            ]
        );
    }
}
?>]]></programlisting>
        <para>
          Un DataSet PHP possède des avantages évidents sur les autres datasets utilisant des
          fichiers :
        </para>
        <itemizedlist>
          <listitem>
            <para>
              Les tableaux PHP peuvent évidemment gérer les valeurs <literal>NULL</literal>.
            </para>
          </listitem>
          <listitem>
            <para>
              Vous n'avez pas besoin de fichiers additionnels pour les assertions et vous pouvez
              les renseigner directement dans les cas de test.
            </para>
          </listitem>
        </itemizedlist>
        <para>
          Pour que ce dataset ressemble aux DataSets au format XML à plat, CSV et YAML, les clefs
          de la première ligne spécifiée définissent les noms de colonne de la table, dans le cas
          précédent, ce serait <quote>id</quote>,
          <quote>content</quote>, <quote>user</quote> and
          <quote>created</quote>.
        </para>
        <para>
          L'implémentation de ce DataSet tableau est simple et
          évidente:
        </para>
        <programlisting><![CDATA[<?php
class MyApp_DbUnit_ArrayDataSet extends PHPUnit_Extensions_Database_DataSet_AbstractDataSet
{
    /**
     * @var array
     */
    protected $tables = [];

    /**
     * @param array $data
     */
    public function __construct(array $data)
    {
        foreach ($data AS $tableName => $rows) {
            $columns = [];
            if (isset($rows[0])) {
                $columns = array_keys($rows[0]);
            }

            $metaData = new PHPUnit_Extensions_Database_DataSet_DefaultTableMetaData($tableName, $columns);
            $table = new PHPUnit_Extensions_Database_DataSet_DefaultTable($metaData);

            foreach ($rows AS $row) {
                $table->addRow($row);
            }
            $this->tables[$tableName] = $table;
        }
    }

    protected function createIterator($reverse = false)
    {
        return new PHPUnit_Extensions_Database_DataSet_DefaultTableIterator($this->tables, $reverse);
    }

    public function getTable($tableName)
    {
        if (!isset($this->tables[$tableName])) {
            throw new InvalidArgumentException("$tableName is not a table in the current database.");
        }

        return $this->tables[$tableName];
    }
}
?>]]></programlisting>
      </section>
      <section id="database.query-sql-dataset">
        <title>Query (SQL) DataSet</title>
        <para>
          Pour les assertions de base de données, vous n'avez pas seulement besoin
          de datasets basés sur des fichiers mais aussi de Datasets basé sur des requêtes/du SQL
          qui contiennent le contenu constaté de la base de données. C'est là que le DataSet Query s'illustre :
        </para>
        <programlisting><![CDATA[<?php
$ds = new PHPUnit_Extensions_Database_DataSet_QueryDataSet($this->getConnection());
$ds->addTable('guestbook');
?>]]></programlisting>
        <para>
          Ajouter une table juste par son nom est un moyen implicite de définir
          la table de données avec la requête suivante :
        </para>
        <programlisting><![CDATA[<?php
$ds = new PHPUnit_Extensions_Database_DataSet_QueryDataSet($this->getConnection());
$ds->addTable('guestbook', 'SELECT * FROM guestbook');
?>]]></programlisting>
        <para>
          Vous pouvez utiliser ceci en indiquant des requêtes arbitraires pour
          vos tables, par exemple en restreignant les lignes, les colonnes ou en
          ajoutant des clauses <literal>ORDER BY</literal>:
        </para>
        <programlisting><![CDATA[<?php
$ds = new PHPUnit_Extensions_Database_DataSet_QueryDataSet($this->getConnection());
$ds->addTable('guestbook', 'SELECT id, content FROM guestbook ORDER BY created DESC');
?>]]></programlisting>
        <para>
          La section relative aux assertions de base de données montrera plus en détails comment
          utiliser le Query DataSet.
        </para>
      </section>
      <section id="database.database-db-dataset">
        <title>Dataset (DB) de base de données</title>
        <para>
          En accédant à la connexion de test, vous pouvez créer automatiquement
          un DataSet constitué de toutes les tables et de leur contenu de la base
          de données indiquée comme second paramètre de la méthode fabrique de
          connexion.
        </para>
        <para>
          Vous pouvez, soit créer un dataset pour la base de données complète
          comme montré dans la méthode <literal>testGuestbook()</literal>, soit le restreindre
          à un ensemble de noms de tables avec une liste blanche comme montré dans
          la méthode <literal>testFilteredGuestbook()</literal>.
        </para>
        <programlisting><![CDATA[<?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class MySqlGuestbookTest extends TestCase
{
    use TestCaseTrait;

    /**
     * @return PHPUnit_Extensions_Database_DB_IDatabaseConnection
     */
    public function getConnection()
    {
        $database = 'my_database';
        $user = 'my_user';
        $password = 'my_password';
        $pdo = new PDO('mysql:...', $user, $password);
        return $this->createDefaultDBConnection($pdo, $database);
    }

    public function testGuestbook()
    {
        $dataSet = $this->getConnection()->createDataSet();
        // ...
    }

    public function testFilteredGuestbook()
    {
        $tableNames = ['guestbook'];
        $dataSet = $this->getConnection()->createDataSet($tableNames);
        // ...
    }
}
?>]]></programlisting>
      </section>
      <section id="database.replacement-dataset">
        <title>DataSet de remplacement</title>
        <para>
          J'ai évoqué les problèmes de NULL avec les DataSet au format XML à
          plat et CSV, mais il y existe un contournement légèrement compliqué
          pour que ces deux types de datasets fonctionnent avec NULLs.
        </para>
        <para>
          Le DataSet de remplacement est un décorateur pour un dataset existant
          et vous permet de remplacer des valeurs dans toute colonne du dataset
          par une autre valeur de remplacement. Pour que notre exemple de livre d'or
          fonctionne avec des valeurs NULL nous indiquons le fichier comme ceci:
        </para>
        <screen><![CDATA[
<?xml version="1.0" ?>
<dataset>
    <guestbook id="1" content="Hello buddy!" user="joe" created="2010-04-24 17:15:23" />
    <guestbook id="2" content="I like it!" user="##NULL##" created="2010-04-26 12:14:20" />
</dataset>
]]></screen>
        <para>
          Nous encapsulons le DataSet au format XML à plat dans le DataSet de remplacement :
        </para>
        <programlisting><![CDATA[<?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class ReplacementTest extends TestCase
{
    use TestCaseTrait;

    public function getDataSet()
    {
        $ds = $this->createFlatXmlDataSet('myFlatXmlFixture.xml');
        $rds = new PHPUnit_Extensions_Database_DataSet_ReplacementDataSet($ds);
        $rds->addFullReplacement('##NULL##', null);
        return $rds;
    }
}
?>]]></programlisting>
      </section>
      <section id="database.dataset-filter">
        <title>Filtre de DataSet</title>
        <para>
          Si vous avez un fichier de fixture conséquent vous pouvez utiliser
          le filtre de DataSet pour des listes blanches ou noires des tables
          et des colonnes qui peuvent être contenues dans un sous-dataset. C'est
          particulièrement commode en combinaison avec le DataSet de base de données pour filtrer les colonnes des datasets.
        </para>
        <programlisting><![CDATA[<?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class DataSetFilterTest extends TestCase
{
    use TestCaseTrait;

    public function testIncludeFilteredGuestbook()
    {
        $tableNames = ['guestbook'];
        $dataSet = $this->getConnection()->createDataSet();

        $filterDataSet = new PHPUnit_Extensions_Database_DataSet_DataSetFilter($dataSet);
        $filterDataSet->addIncludeTables(['guestbook']);
        $filterDataSet->setIncludeColumnsForTable('guestbook', ['id', 'content']);
        // ..
    }

    public function testExcludeFilteredGuestbook()
    {
        $tableNames = ['guestbook'];
        $dataSet = $this->getConnection()->createDataSet();

        $filterDataSet = new PHPUnit_Extensions_Database_DataSet_DataSetFilter($dataSet);
        $filterDataSet->addExcludeTables(['foo', 'bar', 'baz']); // only keep the guestbook table!
        $filterDataSet->setExcludeColumnsForTable('guestbook', ['user', 'created']);
        // ..
    }
}
?>]]></programlisting>
        <blockquote>
          <para>
            <emphasis role="strong">NOTE</emphasis> Vous ne pouvez pas utiliser en même temps le filtrage de colonne d'inclusion
            et d'exclusion sur la même table, seulement sur des tables différentes. De plus, il est
            seulement possible d'appliquer soit une liste blanche, soit une liste
            noire aux tables, mais pas les deux à la fois.
          </para>
        </blockquote>
      </section>
      <section id="database.composite-dataset">
        <title>DataSet composite</title>
        <para>
          Le DataSet composite est très utile pour agréger plusieurs
          datasets déjà existants dans un unique dataset. Quand plusieurs
          datasets contiennent la même table, les lignes sont ajoutées
          dans l'ordre indiqué. Par exemple, si nous avons deux datasets
          <emphasis>fixture1.xml</emphasis> :
        </para>
        <screen><![CDATA[
<?xml version="1.0" ?>
<dataset>
    <guestbook id="1" content="Hello buddy!" user="joe" created="2010-04-24 17:15:23" />
</dataset>
]]></screen>
        <para>
          et <emphasis>fixture2.xml</emphasis>:
        </para>
        <screen><![CDATA[
<?xml version="1.0" ?>
<dataset>
    <guestbook id="2" content="I like it!" user="##NULL##" created="2010-04-26 12:14:20" />
</dataset>
]]></screen>
        <para>
          En utiliser le DataSet composite, nous pouvons agréger les deux fichiers de fixture:
        </para>
        <programlisting><![CDATA[<?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class CompositeTest extends TestCase
{
    use TestCaseTrait;

    public function getDataSet()
    {
        $ds1 = $this->createFlatXmlDataSet('fixture1.xml');
        $ds2 = $this->createFlatXmlDataSet('fixture2.xml');

        $compositeDs = new PHPUnit_Extensions_Database_DataSet_CompositeDataSet();
        $compositeDs->addDataSet($ds1);
        $compositeDs->addDataSet($ds2);

        return $compositeDs;
    }
}
?>]]></programlisting>
      </section>
    </section>
    <section id="database.beware-of-foreign-keys">
      <title>Attention aux clefs étrangères</title>
      <para>
        Lors du SetUp de la fixture l'extension de base de données de PHPUnit
        insère les lignes dans la base de données dans l'ordre où elles sont
        indiquées dans votre fixture. Si votre schéma de base de données
        utilise des clefs étrangères, ceci signifie que vous devez indiquer
        les tables dans un ordre qui ne provoquera pas une violation de contrainte pour ces clefs étrangères.
      </para>
    </section>
    <section id="database.implementing-your-own-datasetsdatatables">
      <title>Implémenter vos propres DataSets/DataTables</title>
      <para>
        Pour comprendre le fonctionnement interne des DataSets et des DataTables
        jetons un oeil sur l'interface d'un DataSet. Vous pouvez sauter cette partie
        si vous ne projetez pas d'implémenter votre propre DataSet ou DataTable.
      </para>
      <programlisting><![CDATA[<?php
interface PHPUnit_Extensions_Database_DataSet_IDataSet extends IteratorAggregate
{
    public function getTableNames();
    public function getTableMetaData($tableName);
    public function getTable($tableName);
    public function assertEquals(PHPUnit_Extensions_Database_DataSet_IDataSet $other);

    public function getReverseIterator();
}
?>]]></programlisting>
      <para>
        L'interface publique est utilisée en interne par l'assertion
        <literal>assertDataSetsEqual()</literal> du cas de test de base de données
        pour contrôler la qualité du dataset. De l'interface
        <literal>IteratorAggregate</literal> le IDataSet
        hérite la méthode <literal>getIterator()</literal> pour parcourir toutes
        les tables du dataset. La méthode additionnelle d'itérateur inverse est
        nécessaire pour réussir à tronquer les tables dans l'ordre inverse à celui indiqué pour satisfaire
        les contraintes de clés étrangères.
      </para>
      <para>
        En fonction de l'implémentation, différentes approches sont prises
        pour ajouter des instances de table dans un dataset. Par exemple,
        les tables sont ajoutées de façon interne lors de la construction
        depuis le fichier source dans tous les datasets basés sur les fichiers comme
        <literal>YamlDataSet</literal>, <literal>XmlDataSet</literal> ou <literal>FlatXmlDataSet</literal>.
      </para>
      <para>
        Une table est également représentée par l'interface suivante :
      </para>
      <programlisting><![CDATA[<?php
interface PHPUnit_Extensions_Database_DataSet_ITable
{
    public function getTableMetaData();
    public function getRowCount();
    public function getValue($row, $column);
    public function getRow($row);
    public function assertEquals(PHPUnit_Extensions_Database_DataSet_ITable $other);
}
?>]]></programlisting>
      <para>
        Mise à part la méthode <literal>getTableMetaData()</literal>, ça parle
        plutôt de soi-même. Les méthodes utilisées sont toutes nécessaires pour
        les différentes assertions de l'extension Base de données expliquées
        dans le chapitre suivant. La méthode
        <literal>getTableMetaData()</literal> doit retourner
        une implémentation de l'interface
        <literal>PHPUnit_Extensions_Database_DataSet_ITableMetaData</literal>
        qui décrit la structure de la table. Elle contient des
        informations sur:
      </para>
      <itemizedlist>
        <listitem>
          <para>
            Le nom de la table
          </para>
        </listitem>
        <listitem>
          <para>
            Un tableau des noms de colonne de la table, classé par leur ordre
            d'apparition dans l'ensemble résultat.
          </para>
        </listitem>
        <listitem>
          <para>
            Un tableau des colonnes clefs primaires.
          </para>
        </listitem>
      </itemizedlist>
      <para>
        Cette interface possède également une assertion qui contrôle si
        deux instances des méta données des tables sont égales et qui sera
        utilisée par l'assertion d'égalité d'ensemble de données.
      </para>
    </section>
  </section>
  <section id="database.the-connection-api">
    <title>L'API de connexion</title>
    <para>
      Il y a trois méthodes intéressantes dans l'interface de connexion
      qui doit être retournée par la méthode
      <literal>getConnection()</literal> du cas de test de base de données :
    </para>
    <programlisting><![CDATA[<?php
interface PHPUnit_Extensions_Database_DB_IDatabaseConnection
{
    public function createDataSet(Array $tableNames = NULL);
    public function createQueryTable($resultName, $sql);
    public function getRowCount($tableName, $whereClause = NULL);

    // ...
}
?>]]></programlisting>
    <orderedlist numeration="arabic">
      <listitem>
        <para>
          La méthode <literal>createDataSet()</literal> crée un DataSet de base de données
          (DB) comme décrit dans la section relative aux implémentations de DataSet.
        </para>
        <programlisting><![CDATA[<?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class ConnectionTest extends TestCase
{
    use TestCaseTrait;

    public function testCreateDataSet()
    {
        $tableNames = ['guestbook'];
        $dataSet = $this->getConnection()->createDataSet();
    }
}
?>]]></programlisting>
      </listitem>
      <listitem>
        <para>
          La méthode <literal>createQueryTable()</literal> peut être utilisée pour
          créer des instances d'une QueryTable, en lui passant un nom de résultat et
          une requête SQL. C'est une méthode pratique quand elle est associée à des
          assertions résultats/table comme cela sera illustré dans la prochaine section
          relative à l'API des assertions de base de données.
        </para>
        <programlisting><![CDATA[<?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class ConnectionTest extends TestCase
{
    use TestCaseTrait;

    public function testCreateQueryTable()
    {
        $tableNames = ['guestbook'];
        $queryTable = $this->getConnection()->createQueryTable('guestbook', 'SELECT * FROM guestbook');
    }
}
?>]]></programlisting>
      </listitem>
      <listitem>
        <para>
          La méthode <literal>getRowCount()</literal> est un moyen pratique d'accéder
          au nombre de lignes d'une table, éventuellement filtrées par une
          clause where supplémentaire. Ceci peut être utilisé pour une simple
          assertion d'égalité :
        </para>
        <programlisting><![CDATA[<?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class ConnectionTest extends TestCase
{
    use TestCaseTrait;

    public function testGetRowCount()
    {
        $this->assertEquals(2, $this->getConnection()->getRowCount('guestbook'));
    }
}
?>]]></programlisting>
      </listitem>
    </orderedlist>
  </section>
  <section id="database.database-assertions-api">
    <title>API d'assertion de base de données</title>
    <para>
      En tant qu'outil de test, l'extension base de données fournit
      certainement des assertions que vous pouvez utiliser pour vérifier
      l'état actuel de la base de données, des tables et du nombre de lignes
      des tables. Cette section décrit ces fonctionnalités en détail :
    </para>
    <section id="database.asserting-the-row-count-of-a-table">
      <title>Faire une assertion sur le nombre de lignes d'une table</title>
      <para>
        Il est souvent très utile de vérifier si une table contient un nombre
        déterminé de lignes. Vous pouvez facilement réaliser cela sans code
        de liaison supplémentaire en utilisant l'API de connexion. Disons que
        nous voulons contrôler qu'après une insertion d'une ligne dans notre
        livre d'or, nous n'avons plus seulement nos deux entrées initiales
        qui nous ont accompagnées dans tous les exemples précédents, mais aussi une troisième :
      </para>
      <programlisting><![CDATA[<?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class GuestbookTest extends TestCase
{
    use TestCaseTrait;

    public function testAddEntry()
    {
        $this->assertEquals(2, $this->getConnection()->getRowCount('guestbook'), "Pre-Condition");

        $guestbook = new Guestbook();
        $guestbook->addEntry("suzy", "Hello world!");

        $this->assertEquals(3, $this->getConnection()->getRowCount('guestbook'), "Inserting failed");
    }
}
?>]]></programlisting>
    </section>
    <section id="database.asserting-the-state-of-a-table">
      <title>Faire une assertion sur l'état d'une table</title>
      <para>
        L'assertion précédente est utile, mais nous voudrons certainement tester
        le contenu présent de la table pour vérifier que toutes les valeurs ont
        été écrites dans les bonnes colonnes. Ceci peut être réalisé avec une assertion
        de table.
      </para>
      <para>
        Pour cela, nous devons définir une instance de Query Table qui tire
        son contenu d'un nom de table et d'une requête SQL et le compare
        à un DataSet basé sur un fichier/tableau.
      </para>
      <programlisting><![CDATA[<?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class GuestbookTest extends TestCase
{
    use TestCaseTrait;

    public function testAddEntry()
    {
        $guestbook = new Guestbook();
        $guestbook->addEntry("suzy", "Hello world!");

        $queryTable = $this->getConnection()->createQueryTable(
            'guestbook', 'SELECT * FROM guestbook'
        );
        $expectedTable = $this->createFlatXmlDataSet("expectedBook.xml")
                              ->getTable("guestbook");
        $this->assertTablesEqual($expectedTable, $queryTable);
    }
}
?>]]></programlisting>
      <para>
        Maintenant, nous devons écrire le fichier XML à plat <emphasis>expectedBook.xml</emphasis>
        pour cette assertion :
      </para>
      <screen><![CDATA[
<?xml version="1.0" ?>
<dataset>
    <guestbook id="1" content="Hello buddy!" user="joe" created="2010-04-24 17:15:23" />
    <guestbook id="2" content="I like it!" user="nancy" created="2010-04-26 12:14:20" />
    <guestbook id="3" content="Hello world!" user="suzy" created="2010-05-01 21:47:08" />
</dataset>
]]></screen>
      <para>
        Cette assertion ne réussira que si elle est lancée très exactement le
        <emphasis>2010–05–01 21:47:08</emphasis>. Les dates posent un problème spécial
        pour le test de base de données et nous pouvons contourner l'échec
        en omettant la colonne <quote>created</quote> de
        l'assertion.
      </para>
      <para>
        Le fichier au format XML à plat adapté <emphasis>expectedBook.xml</emphasis>
        devra probablement ressembler à ce qui suit pour que
        l'assertion réussisse :
      </para>
      <screen><![CDATA[
<?xml version="1.0" ?>
<dataset>
    <guestbook id="1" content="Hello buddy!" user="joe" />
    <guestbook id="2" content="I like it!" user="nancy" />
    <guestbook id="3" content="Hello world!" user="suzy" />
</dataset>
]]></screen>
      <para>
        Nous devons corriger l'appel à Query Table:
      </para>
      <programlisting><![CDATA[<?php
$queryTable = $this->getConnection()->createQueryTable(
    'guestbook', 'SELECT id, content, user FROM guestbook'
);
?>]]></programlisting>
    </section>
    <section id="database.asserting-the-result-of-a-query">
      <title>Faire une assertion sur le résultat d'une requête</title>
      <para>
        Vous pouvez également faire une assertion sur le résultat de requêtes
        complexes avec l'approche Query Table, simplement en indiquant le nom
        d'un résultat avec une requête et en le comparant avec un ensemble de données:
      </para>
      <programlisting><![CDATA[<?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class ComplexQueryTest extends TestCase
{
    use TestCaseTrait;

    public function testComplexQuery()
    {
        $queryTable = $this->getConnection()->createQueryTable(
            'myComplexQuery', 'SELECT complexQuery...'
        );
        $expectedTable = $this->createFlatXmlDataSet("complexQueryAssertion.xml")
                              ->getTable("myComplexQuery");
        $this->assertTablesEqual($expectedTable, $queryTable);
    }
}
?>]]></programlisting>
    </section>
    <section id="database.asserting-the-state-of-multiple-tables">
      <title>Faire une assertion sur l'état de plusieurs tables</title>
      <para>
        Evidemment, vous pouvez faire une assertion sur l'état de plusieurs tables à la fois
        et comparer un ensemble de données obtenu par une requête avec un ensemble de données
        basé sur un fichier. Il y a deux façons différentes de faire des assertions de DataSet.
      </para>
      <orderedlist numeration="arabic">
        <listitem>
          <para>
            Vous pouvez utiliser le Database (DB) Dataset à partir de la
            connexion et le comparer au DataSet basé sur un fichier.
          </para>
          <programlisting><![CDATA[<?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class DataSetAssertionsTest extends TestCase
{
    use TestCaseTrait;

    public function testCreateDataSetAssertion()
    {
        $dataSet = $this->getConnection()->createDataSet(['guestbook']);
        $expectedDataSet = $this->createFlatXmlDataSet('guestbook.xml');
        $this->assertDataSetsEqual($expectedDataSet, $dataSet);
    }
}
?>]]></programlisting>
        </listitem>
        <listitem>
          <para>
            Vous pouvez construire vous-même le DataSet:
          </para>
          <programlisting><![CDATA[<?php
use PHPUnit\Framework\TestCase;
use PHPUnit\DbUnit\TestCaseTrait;

class DataSetAssertionsTest extends TestCase
{
    use TestCaseTrait;

    public function testManualDataSetAssertion()
    {
        $dataSet = new PHPUnit_Extensions_Database_DataSet_QueryDataSet();
        $dataSet->addTable('guestbook', 'SELECT id, content, user FROM guestbook'); // additional tables
        $expectedDataSet = $this->createFlatXmlDataSet('guestbook.xml');

        $this->assertDataSetsEqual($expectedDataSet, $dataSet);
    }
}
?>]]></programlisting>
        </listitem>
      </orderedlist>
    </section>
  </section>
  <section id="database.frequently-asked-questions">
    <title>Foire aux questions</title>
    <section id="database.will-phpunit-re-create-the-database-schema-for-each-test">
      <title>PHPUnit va-t'il (re-)créer le schéma de base de données pour chaque
             test ?</title>
      <para>
        Non, PHPUnit exige que tous les objets de base de données soit disponible quand
        la suite démarre. La base de données, les tables, les séquences, les triggers et les
        vues doivent être créés avant que vous exécutiez la suite de tests.
      </para>
      <para>
        <ulink url="http://www.doctrine-project.org">Doctrine 2</ulink> ou
        <ulink url="http://www.ezcomponents.org">eZ Components</ulink> possèdent
        des outils puissants qui vous permettent de créer le schéma de base de données
        à partir de structures de données définies préalablement, cependant, ceux-ci
        doivent être reliés à l'extension PHPUnit pour permettre la recréation automatique
        de la base de données avant que la suite de tests complète ne soit exécutée.
      </para>
      <para>
        Puisque chaque test nettoie complètement la base de données, vous n'avez
        même pas obligation de re-créer la base de donnée pour chaque exécution des tests.
        Une base de données disponible de façon permanente fonctionne parfaitement.
      </para>
    </section>
    <section id="database.am-i-required-to-use-pdo-in-my-application-for-the-database-extension-to-work">
      <title>Suis-je obligé d'utiliser PDO dans mon application pour que l'extension de base de
             données fonctionne ?</title>
      <para>
        Non, PDO n'est nécessaire que pour le nettoyage et la configuration de la fixture et
        pour les assertions. Vous pouvez utiliser n'importe laquelle des abstractions de base de
        données que vous voulez dans votre propre code.
      </para>
    </section>
    <section id="database.what-can-i-do-when-i-get-a-too-much-connections-error">
      <title>Que puis-je faire quand j'obtiens une erreur
             <quote>Too much Connections (Trop de connexions)</quote> ?</title>
      <para>
        Si vous ne mettez pas en cache l'instance PDO qui est créée dans
        la méthode <literal>getConnection()</literal> du cas de test
        le nombre de connexions à la base de données est augmenté d'une unité ou plus
        pour chaque test de base de données. Avec la configuration par défaut, MySql
        n'autorise qu'un maximum de 100 connexions concurrentes. Les autres moteurs
        de bases de données possèdent également des limites du nombre maximum de connexions.
      </para>
      <para>
        La sous-section
        <quote>Utilisez votre propre cas de test de base de données abstrait</quote> illustre comment
        vous pouvez empêcher cette erreur de survenir en utilisant une unique instance de PDO en cache
        dans tous vos tests.
      </para>
    </section>
    <section id="database.how-to-handle-null-with-flat-xml-csv-datasets">
      <title>Comment gérer les valeurs NULL avec les DataSets au format XML à plat / CSV ?</title>
      <para>
        Ne le fait pas. Pour cela, vous devez utiliser des
        DataSets XML ou YAML.
      </para>
    </section>
  </section>
</chapter>
